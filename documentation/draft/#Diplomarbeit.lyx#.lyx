#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrartcl
\begin_preamble
\usepackage[automark]{scrpage2}
\usepackage{url}
\clearscrheadfoot
\ihead{KROPF Simon | GRUBMAIR David - 2011/2012 - 5BHDVK}
\chead{\vspace*{-7mm}\hrulefill}
\ohead{Room Control System}
\ifoot{30.03.2012}
\ofoot{\pagemark}
\pagestyle{scrheadings}
\renewcommand*{\pagemark}{{\pnumfont{\pagename~\thepage}}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language american
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 4.3cm
\rightmargin 3cm
\bottommargin 4.3cm
\headsep 1.2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Subject

\series bold
\size huge
Diploma thesis
\series default
\size default

\begin_inset Newline newline
\end_inset


\begin_inset VSpace bigskip
\end_inset

Höhere Technische Bundeslehranstalt Leonding
\begin_inset Newline newline
\end_inset

Abteilung EDV und Organisation
\begin_inset Newline newline
\end_inset


\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Title

\size giant
Room Control System
\end_layout

\begin_layout Date
\begin_inset VSpace -2cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\series bold
\size largest
Home Automation
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Author
handed in from:
\begin_inset Newline newline
\end_inset

GRUBMAIR David
\begin_inset Newline newline
\end_inset

2011/2012
\begin_inset Newline newline
\end_inset

5 BHDVK
\end_layout

\begin_layout Author
KROPF Simon
\begin_inset Newline newline
\end_inset

2011/2012
\begin_inset Newline newline
\end_inset

5 BHDVK
\end_layout

\begin_layout Date
at:
\begin_inset Newline newline
\end_inset

10.05.2012
\end_layout

\begin_layout Publishers
supervised and assessed by:
\begin_inset Newline newline
\end_inset

Dipl.
 Ing.
 Prof.
 Gerald Köck
\begin_inset Newline newline
\end_inset

Mag.
 Dr.
 Prof.
 Thomas Stütz
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
\noindent
Declaration of academic honesty
\end_layout

\begin_layout Standard
We hereby declare under penalty of perjury, that the present paper was written
 independetly and without assistance, other than the specified sources and
 tools used, not all the sources used vebatim or in essance taken from sites
 identified as such have.
\end_layout

\begin_layout Standard
\begin_inset VSpace 1cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align right
Leonding, am ...................................
\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 1cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align right
.....................................................
\begin_inset space \hfill{}
\end_inset

.....................................................
\begin_inset Newline newline
\end_inset


\begin_inset space \hspace{}
\length 1.6cm
\end_inset

Kropf Simon
\begin_inset space \hfill{}
\end_inset

David Grubmair
\begin_inset space \hspace{}
\length 1.45cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\family sans
\series bold
\size larger
Credits
\end_layout

\begin_layout Standard
\begin_inset VSpace 1cm
\end_inset


\end_layout

\begin_layout Quote
Our sincerest thanks to our supervisors Dipl.
 Ing.
 Prof.
 Gerald Köck and Mag.
 Dr.
 Prof.
 Thomas Stütz for supporting us by our diploma thesis and for their heavily
 engagement.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Newpage newpage
\end_inset


\family sans
\series bold
\size larger
Abstract
\end_layout

\begin_layout Quote
This diploma thesis describes the developement of a Home Automation System
 used to observe environmental conditions and furthermore to act based on
 these conditions.
\end_layout

\begin_layout Quote
The first part covers the thoughts and planning as well as the goals behind
 our system.
 Within this part we used technologies which were suited best for our system.
 The product does not cost much and on the other side, it is user friendly
 and efficient.
 Due to the fact that we splitted our project up into two parts, we had
 to make exact interface definitions.
 One part includes the server-side system and the other part the microcontroller
 and the hardware behind it.
\end_layout

\begin_layout Quote
The second part deals with the implementation and the procedure of testing.
 This part is splitted up into two parts, which are the server and the microcont
roller.
 At first the components, which were developed from us, and therefore the
 utilized technologies are described and explained and afterwards the connection
s between them.
 The critical parts, which are responsible for the business logic and the
 main operations, are outlined in detail.
\end_layout

\begin_layout Quote
The last part compares the planning process to the successful realization
 and displays the conclusions of our self evaluation.
\end_layout

\begin_layout Quote
\begin_inset VSpace 1cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
\noindent
Introduction
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
There are many home automation systems available on the market, but no software
 offers the ability to connect your Android tablet directly to it as the
 main control screen.
 Our goal was to make a flexible software which offers many possibilities
 and which is able to connect directly to an Android tablet as the central
 station.
 Many of the systems on the market are also very expensive because they
 use decent displays and stationary hardware.
 With our software, costumers can use one or more Arduino boards which are
 not very expensive and a decent Android hardware which the user is probably
 already owning.
\end_layout

\begin_layout Standard
Another point why we have seen the need to redesign such a system was the
 flexibility to use other sensors or actors.
 In many Home Automation Systems users are forced to take the hardware they
 offer and probably have no way to connect their own, maybe cheaper hardware
 if they want to.
 On the one hand, this means that the customer needs to develop his own
 drivers but on the other hand he has a maximum of flexibility.
\end_layout

\begin_layout Standard
Due to the reasons mentioned above we made a solution which is at first
 fully configurable by simple configuration and upgradeable to the fact
 that devices, actors and sensor can be easily developed and inserted into
 the system.
\end_layout

\begin_layout Subsection
Conceptual formulation
\end_layout

\begin_layout Standard
The concept was creating a flexible system which is upgradeable and configureabl
e by users.
 Therefore it has to be easily administrated and the overall usability has
 to be on a decent level.
 Administration is done via a Website which is beside the Android device
 the main control system.
 It's the standard way to connect to the system.
 That's because nearly every new smartphone is connected to the internet
 and can visit the website which is not based on the phones operating system.
 Developers can also make apps for our solution on any Android device which
 supports ADK (Android Development Kit) with defined interfaces.
\end_layout

\begin_layout Standard
Other devices (for example IOS Devices, PC clients) are also able to connect
 to the system using defined web services with autentification.
 It is possible that without knowing the internal structure, these devices
 can control the whole system.
\end_layout

\begin_layout Subsection
Differences to other products
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Planning
\end_layout

\begin_layout Subsection
Involved parties
\end_layout

\begin_layout Standard
There were four persons involved in this thesis.
 Splitted up, there were two teachers and two students.
\end_layout

\begin_layout Standard
Dr.
 Dipl.
 Ing Thomas Stütz, teacher of the HTBLA-Leonding, was our superviser in
 the Java side of the projekt.
 He contributed his ideas to the project for the technical implementation,
 controlled the improvement of the work and he proved, if the milestones
 were reached in the planned time.
\end_layout

\begin_layout Standard
Dipl.
 Ing Gerald Köck, also teacher of the HTBLA-Leonding, was our assessor at
 the Arduino side of the diploma thesis.
 If we had problems implementing some aspects of the system, he lead us
 to the right way with his ideas.
 The general workflow concept is mainly based on his thoughts, but some
 aspect have been changed.
\end_layout

\begin_layout Standard
Meetings with the two assessors were held regularly every week or at least
 every two weeks.
\end_layout

\begin_layout Subsection
General approach
\end_layout

\begin_layout Standard
We didn't use a certain planning system like the V-Modell or complex planning
 models like that.
 The approach of ours were to make use of the normal, simple and easy-going
 project documentation.
 Documents and informations like the project handbook, structure plans or
 project reports were our guideline for this diploma thesis.
 During the planning and development we had periodic meetings with our superviso
rs, for showing them the ongoing advance, discussing over further development
 and for perfecting previous components.
 Because of that we were able to create and build in new requirements and
 exceptions, which were unaware to us before.
 Therefore our software became more and more adapted to our goals, despite
 of the growing complexity.
\end_layout

\begin_layout Standard
Because of the growing complexity and the overflowing ideas we got, we were
 forced to prioritize these ideas.
 On this prioritization we implemented and merged them into the system one
 after another to make sure to get the functionality with the most capital
 importance to work before getting less significant functionalities done.
\end_layout

\begin_layout Subsection
Initial situation
\end_layout

\begin_layout Subsubsection
General
\end_layout

\begin_layout Subsubsection
Quantity structure of parts
\end_layout

\begin_layout Standard
If the profiles and tasks are already set, then they will use about 50 to
 100 messages between server and arduino if logging to the server isn't
 activated.
 
\end_layout

\begin_layout Subsection
Goals and requirements
\end_layout

\begin_layout Subsubsection
Goals of the new system
\end_layout

\begin_layout Standard
Following goals should be accomplished by our system:
\end_layout

\begin_layout Itemize
Controlling electronical devices in a household
\end_layout

\begin_layout Itemize
Automation through assocations between sensors and actors
\end_layout

\begin_layout Itemize
Remote access over Web-Inteface
\end_layout

\begin_layout Itemize
Local access over Android-App
\end_layout

\begin_layout Standard
This diploma thesis should make it possible to control the electronical
 devices over a household.
 This is accomplished by gaining access through a Web-Interface or a Android-bas
ed device.
 To create a certain automation in the system, it's able to make tasks or
 to define conditions on devices.
 Through the two mentioned user interfaces it is possible to control these
 devices in any way.
 On one of these user interfaces the user is also able to create, edit and
 delete the above mentioned conditions and tasks.
\end_layout

\begin_layout Standard
The Web-Interface will be implemented on a Java EE Server, on which the
 SOAP-Webservice is running.
 As a local control station there will be a Android - Tablet.
\end_layout

\begin_layout Standard
Because of our interfaces (SOAP, MCP) it's possible to expansion the end
 devices, such as our Java EE Server or Android - Tablet, in any way.
\end_layout

\begin_layout Subsubsection
Requirements
\end_layout

\begin_layout Standard
Requirements of the individual parts of the system:
\end_layout

\begin_layout Itemize
Arduino-Microcontroller:
\end_layout

\begin_deeper
\begin_layout Itemize
Activation piloting of the actors and sensors
\end_layout

\begin_layout Itemize
Persisting of the RCS - Devices on the SD - Card
\end_layout

\begin_layout Itemize
Multible and simultaneously connections to server/Android-devices
\end_layout

\begin_layout Itemize
Logging of all actions in serveral modes:
\end_layout

\begin_deeper
\begin_layout Itemize
on SD - Card
\end_layout

\begin_layout Itemize
through serial connection
\end_layout

\begin_layout Itemize
on the server
\end_layout

\begin_layout Itemize
per broadcast to the network
\end_layout

\end_deeper
\begin_layout Itemize
Communicating with other devices through our own developed protocol (MCP)
\end_layout

\end_deeper
\begin_layout Itemize
Java EE Server:
\end_layout

\begin_deeper
\begin_layout Itemize
Persisting of the RCS - Devices into a database
\end_layout

\begin_layout Itemize
Communicating with other devices through our own developed protocol (MCP)
 or via WebService (SOAP)
\end_layout

\begin_layout Itemize
Control and manage the system over a Web - Interface
\end_layout

\begin_layout Itemize
Automation through managable tasks and profiles
\end_layout

\begin_layout Itemize
Persist incoming (from arduino) and own logs into a database
\end_layout

\end_deeper
\begin_layout Itemize
Android Application:
\end_layout

\begin_deeper
\begin_layout Itemize
Provide libaries to easily create and connect to our system for other developers
\end_layout

\begin_layout Itemize
Exchanging data with our stationary microcontroller and control the implemented
 devices
\end_layout

\end_deeper
\begin_layout Subsection
Concept
\end_layout

\begin_layout Subsubsection
Workflow description
\end_layout

\begin_layout Standard
There are four workflows which we cover in our solution due the fact that
 there is more than one way to connect.
\end_layout

\begin_layout Standard
Established Connection with an Android Device
\end_layout

\begin_layout Standard
Android devices can connect whith the Arduino in two Ways:
\end_layout

\begin_layout Subsubsection*
Workflow 1
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Android ADK Connection.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Android ADK Connection 
\begin_inset CommandInset label
LatexCommand label
name "fig:Android ADK Connection"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this workflow the Android unit is connected directly to the arduino base
 station via the ADK framework which allows devices to connect through USB.
 The Android capable device is used as a stationary monitor and control
 screen interfacing with an user through a full flexible graphical user
 interface.
 User inputs are processed by the app running and then MCP(Minimal Communication
 Protocol, see S.) messages are created and sent through the USB connection.
 The commands are intpreted by the Arduino microcontroller and the actions
 are then applied to the corresponding Actors or Sensors.
 Example applications for this workflow would be a light control system
 or a rollerblade management system or a system where both are combined.
\end_layout

\begin_layout Subsubsection*
Workflow 2
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Website Connection.png
	scale 75

\end_inset


\begin_inset Caption

\begin_layout Plain Layout

\lang naustrian
Website connection UML 
\begin_inset CommandInset label
LatexCommand label
name "fig:Website connection UML"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This workflow describes the generic access to the system with the web interface.
 It is possible to connect from everywhere with a client capable of browsing
 the internet.
 The user interface offers the availability to manage all devices, check
 their states and read the global Sensor values.
 The webserver then processes the input, generates MCP messages and sends
 it to the defined IP-Adress.
 IP-Adresses of servers are administrated whithin the website.
 The Arduino microcontroller then interprets the commands and the actions
 are then applied to the corresponding Actors or Sensors.
 In addition all the administrative task can be done in the Java EE-Application
 and a basic security athentication is also provided.
\end_layout

\begin_layout Subsubsection*
Workflow 3
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\lang naustrian
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Android Socket Connection.png

\end_inset


\lang american

\begin_inset Caption

\begin_layout Plain Layout

\lang naustrian
Android Socket Connection
\begin_inset CommandInset label
LatexCommand label
name "fig:Android Socket Connection"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the Android unit is not directly connected to the arduino base station,
 our implementation offers the availabiliy to connect through a socket connectio
n.
 We provide custom Java source files which allow easy connection to it whithout
 knowing the structure of MCP.
 The connection is established directly to the Android unit and commands
 are sent to it.
 In the best case, the Android app detects when an direct connection is
 available and changes the connection type.
\end_layout

\begin_layout Subsubsection*
Workflow 4
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/SOAP Connection.png
	scale 75

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
SOAP Connection
\begin_inset CommandInset label
LatexCommand label
name "fig:SOAP Connection"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Any other Device, for example IOs based Devices or Windows phones can connect
 to the controll unit via defined SOAP interfaces.
 Through this interfaces we offer the ability to use the exact same funktions
 as used when connection directly via USB.
 This workflow was created because otherwise, any device which is not Android
 based must impement the whole Protokoll to connect to it.
 Instead, the device connects via SOAP to the main Station and the Java
 EE server interprets the request and sends it to the arduino microcontroller.
\end_layout

\begin_layout Subsubsection
System architecture
\end_layout

\begin_layout Standard
To exploit the benefits from the backend to the frontend the best, the system
 architecture is build heterogeneous.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Systemarchitecture"

\end_inset

 shows an overview.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename system-overview-pres.tiff
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Systemarchitecture
\begin_inset CommandInset label
LatexCommand label
name "fig:Systemarchitecture"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Arduino
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Processor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ATmega2560
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SRAM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 KB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operating Voltage
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5V
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Clock Speed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 MHZ
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Caption

\begin_layout Plain Layout
Power Data Arduino
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Java EE Server
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Processor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,4 GHz Intel Core 2 Duo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Memory
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 GB 1067 MHz DDR3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hard disk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
250 GB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operating system
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mac OS X Lion 10.7.3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Caption

\begin_layout Plain Layout
Power data Java EE Server
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Database
\end_layout

\begin_layout Standard
The included 
\begin_inset Quotes gld
\end_inset

Apache Derby
\begin_inset Quotes grd
\end_inset

 is used as database with the integrated derby network client.
\end_layout

\begin_layout Standard
The Derby network client provides network connectivity to the Derby Network
 Server.
 It is distributed as an additional jar file, derbyclient.jar, with an entirely
 independent code base from the embedded driver.
\end_layout

\begin_layout Standard

\series bold
Application Server
\end_layout

\begin_layout Standard
As our application server we use 
\begin_inset Quotes gld
\end_inset

GlassFish v3.1.2
\begin_inset Quotes grd
\end_inset

.
\end_layout

\begin_layout Standard
GlassFish is the Reference implementation of Java EE and as such supports
 Enterprise JavaBeans, JPA, JavaServer Faces, JMS, RMI, JavaServer Pages,
 servlets, etc.
 This allows developers to create enterprise applications that are portable
 and scalable, and that integrate with legacy technologies.
 Optional components can also be installed for additional services.
\end_layout

\begin_layout Standard

\series bold
Web service
\end_layout

\begin_layout Standard
SOAP, originally defined as Simple Object Access Protocol, is a protocol
 specification for exchanging structured information in the implementation
 of Web Services in computer networks.
 It relies on Extensible Markup Language (XML) for its message format, and
 usually relies on other Application Layer protocols, most notably Hypertext
 Transfer Protocol (HTTP) and Simple Mail Transfer Protocol (SMTP), for
 message negotiation and transmission.
\end_layout

\begin_layout Standard

\series bold
Clients
\end_layout

\begin_layout Standard
As a client any operating system can be installed and also any browser can
 be used.
 
\end_layout

\begin_layout Subsection
Projekt planning
\end_layout

\begin_layout Subsubsection
Projekt structure
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/pictures/project-structure-plan.jpg
	scale 80
	BoundingBox 0bp 0bp 577bp 428bp

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Project structure plan
\begin_inset CommandInset label
LatexCommand label
name "fig:Project structure plan"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Project structure plan"

\end_inset

 there's displayed the project structure.
 During the implementation it was essential to develop the modules simultaneousl
y, because they had to communicate among one another and therefore they
 are closely linked.
 This kind of project structure plan is called 
\begin_inset Quotes gld
\end_inset

mixed project structure plan
\begin_inset Quotes grd
\end_inset

, which means that he is first divided by modules and after that by work
 packages and accordingly development phase.
\end_layout

\begin_layout Subsubsection
Time scheduling
\end_layout

\begin_layout Subsubsection*
Milestones
\end_layout

\begin_layout Standard
Based on the project structure plan the work effort of the work packages
 were estimated.
 Following the appointments for the milestones could be determined.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Milestones"

\end_inset

 shows the work packages and the planned completion.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="2">
<features headTopDL="true" headBottomDL="true" tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Work package
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Planned completion 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collecting ideas -> concept
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Beginning October
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Project handbook
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mid October
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Creating and implementing data model
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
End October
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implementation of connection - and event - handling
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
End November
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implementation entities and entity - listener
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
End November
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Debriefing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
End November
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implementation of MCP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mid January
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implementation of persistence and logging
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mid January
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Debriefing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mid January
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implementation of web service and parts of web interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Beginning March
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implementation of devices
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Beginning March
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Debriefing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Beginning March
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complete implementation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mid March
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tests and changes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
End March
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Completion
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Beginning April
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Caption

\begin_layout Plain Layout
Milestones
\begin_inset CommandInset label
LatexCommand label
name "tab:Milestones"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Impementation
\end_layout

\begin_layout Subsection
Description of used technologies
\end_layout

\begin_layout Subsubsection
Java 6
\end_layout

\begin_layout Quotation

\emph on
\begin_inset Quotes gld
\end_inset

Java is an object-oriented programming language, which is characterized
 by several key characteristics.
 These make it universally applicable and interesting to the industry as
 a robust programming language.
 Since Java allows object-oriented programming, developers are able to program
 modern and reusable software components.
\begin_inset Quotes grd
\end_inset

 <insert citation>
\end_layout

\begin_layout Subsubsection*
Bytecode and machinecode
\end_layout

\begin_layout Standard
One characteristic of Java is portability, which means that computer programs
 written in the Java language must run similarly on any hardware/operating-syste
m platform.
 This is achieved by compiling the Java language code to an intermediate
 representation called Java bytecode, instead of directly to platform-specific
 machine code.
 Java bytecode instructions are analogous to machine code, but are intended
 to be interpreted by a virtual machine (VM) written specifically for the
 host hardware.
 End-users commonly use a Java Runtime Environment (JRE) installed on their
 own machine for standalone Java applications, or in a Web browser for Java
 applets.
\end_layout

\begin_layout Standard
A major benefit of using bytecode is porting.
 However, the overhead of interpretation means that interpreted programs
 almost always run more slowly than programs compiled to native executables
 would.
 Just-in-Time (JIT) compilers were introduced from an early stage that compile
 bytecodes to machine code during runtime.
\end_layout

\begin_layout Subsubsection
JPA 
\end_layout

\begin_layout Standard
The Java Persistence API (JPA) is an interface for Java applications, which
 simplifies the assignment and transfer of objects to database records.
 It simplifies object-relational mapping, which is about saving objects
 in a Java application into a relational database which are not originally
 designed for object-oriented data structures.
 The Java Persistence API was developed as a project of the JSR 220 Expert
 Group and first released in May 2006.
\end_layout

\begin_layout Subsubsection
Oracle GlassFish Application Server v3.1.2
\end_layout

\begin_layout Standard
GlassFish was originally an open-source project that was originally developed
 by Sun Microsystems.
 In addition to the open source version and a commercial version was developed.
 The differences between these two versions are irrelevant to this diploma
 thesis.
 The commercial version includes enhancements such as clustering.
\end_layout

\begin_layout Standard
The Application Server provides a runtime environment for Java applications
 and web services.
 Not only the Java Standard Edition (JavaSE) is used, but also the Java
 Enterprise Edition (Java EE).
\end_layout

\begin_layout Standard
Among other things GlassFish Application Server supports following modules:
\end_layout

\begin_layout Itemize
Enterprise Module: A Enterprise module or Enterprise application called,
 is part of JavaEE and refers to a collection of servlets, EJBs, HTML pages,
 classes and other resources that can be uploaded to an application server,
 so that they can work together.
 The difference to a Web module is that the EJBs and HTML pages are splitted
 up in two different projects.
 These components will not be uploaded individually, JAR and WAR file, then
 these two are packaged into an EAR file and then uploaded.
\end_layout

\begin_layout Itemize
Web Module: A Web module or Web application called, is part of JavaEE and
 refers to a collection of servlets, EJBs, HTML pages, classes and other
 resources that can be uploaded to an application server, so that they can
 work together.
 These components will not be uploaded individually, but packaged into a
 WAR file and then uploaded.
\end_layout

\begin_layout Itemize
EJB Module: An EJB module is an executable software unit, which consists
 of one or more enterprise beans.
 The standard format for this module is the JAR archive.
\end_layout

\begin_layout Itemize
Application Client Module: Again, a JAR archive, which consists of several
 classes.
 It is a client application that makes it possible to access to EJB modules.
 This module is downloaded by clients if it's in use.
 It's not executed on the server, but locally on the client.
\end_layout

\begin_layout Standard
In the present work a Enterprise web module was used, which accesses the
 database via JPA.
\end_layout

\begin_layout Subsubsection
Apache Derby
\end_layout

\begin_layout Standard
Apache Derby is a project of the Apache Software Foundation, which developed
 an eponymous Java-based relational database management system.
 Apache Derby is one of the lightweight databases, as it has in the delivery
 of only two megabytes in size and easily installable.
 Derby is mainly but not exclusively, used in Java projects.
\end_layout

\begin_layout Standard
The software was originally developed by the company Cloudscape Inc., in
 Oakland (California) under the name JBMS.
 The first version was released in 1997.
 The product was later renamed to "Cloudscape".
 1999 Cloudscape was bought by the company Informix Software Inc., and in
 2001 the database division was acquired by IBM.
\end_layout

\begin_layout Standard
In 2004 IBM transferred Cloudscape to the Apache Software Foundation software
 under the name "Derby" as free software.
 As of early 2005 Sun Microsystems participated in Derby.
 In 2006 Derby was integrated in the Java Development Kit as Java DB from
 Java 6 and it is now also supported by Sun Microsystems.
\end_layout

\begin_layout Subsubsection
Arduino
\end_layout

\begin_layout Standard
Arduino is an decandent of the Open Source Wiring Platform designed to make
 electronic components more accessable.
 Wiring is a development platform consisting of three parts: the programming
 language, the integrated development environment and a single board microcontro
ller.
 The language basically consists of C/C++ although there is no main() function
 and a few minor differences.
 Instead developers have to devine a loop() and a setup() function.
 These files are called Sketches and have the endings .pde.
 Part of the language is the Wiring library which offers common input/output
 functions.
\end_layout

\begin_layout Standard
Every sketch has the same structure:
\end_layout

\begin_layout LyX-Code
\begin_inset listings
lstparams "breaklines=true,language={C++}"
inline false
status open

\begin_layout LyX-Code

#define
\end_layout

\begin_layout LyX-Code

#include <Libraries>
\end_layout

\begin_layout LyX-Code

void setup() 
\end_layout

\begin_layout LyX-Code

{
\end_layout

\begin_layout LyX-Code

	//initialise routines
\end_layout

\begin_layout LyX-Code

} 
\end_layout

\begin_layout LyX-Code

void loop()
\end_layout

\begin_layout LyX-Code

{
\end_layout

\begin_layout LyX-Code

	//method is called in an endless iteration
\end_layout

\begin_layout LyX-Code

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The IDE is cross platform software written in Java and so available for
 every Operating System where Java is available.
 The hardware itself is entirely open-source meaning that the whole circuit
 layout can be modified and costumized.
 The framework on which Arduino is based had been ported to various microcontrol
lers for example the ARM Cortex R3.
 Whithout any changes on the software side, it is posible to change the
 controller underneath.
 Specific functions only available for the current controller must'n be
 used, otherwise you cannot change it.
 As mentioned before, developing for the Arduino allows the developer to
 on the one side be platform unspezific using functions from the framework,
 on the other side it can be very controller specific when functions are
 not available otherwise.
 
\end_layout

\begin_layout Quotation
As of May 2011, more than 300,000 Arduino units are "in the wild." 
\begin_inset CommandInset citation
LatexCommand cite
key "Arduino_A"

\end_inset

 
\end_layout

\begin_layout Standard
This shows that the Arduino is becoming more and more popular.
 The main reason for it is that even for people which are not used to electronic
s, it offers the ability to interface with hardware in an relativ easy way.
 Official arduino candidates are based on the megaAVR series of chips specifical
ly the ATmega8, ATmega168, ATmega328, ATmega1280, and ATmega2560.
 Included in the standard software is a bootloader which simplifies the
 developing process and there's no need for an external programmer.
 (Apendix A: Arduino Models)
\end_layout

\begin_layout Standard
So called Shields are available for the Arduino which are exactly fitting
 into the open ports, it's stackable.
 This means that for example an ethernet shield which is used in our solution
 can be easily plugged in and programmed.
 The platform has an huge user base with tons of librarys available for
 free in the internet.
\end_layout

\begin_layout Quotation
\begin_inset Quotes gld
\end_inset

Arduino was built around the Wiring project of Hernando Barragan.
 Wiring was Hernando's thesis project at the Interaction Design Institute
 Ivrea.
 It was intended to be an electronics version of Processing that used our
 programming environment and was patterned after the Processing syntax.
 It was supervised by myself and Massimo Banzi, an Arduino founder.
 I don't think Arduino would exist without Wiring and I don't think Wiring
 would exist without Processing.
 
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Arduino_B"

\end_inset


\end_layout

\begin_layout Standard
The Arduino syntax is patterned after the Processing syntax.
 Processing is an open source programming language and an integrated development
 environment built for graphic, simulation and animation programms.
 It is a simplified version of Java allowing easy interactions with graphical
 elements.
 Essentially, the programming language intruduced in the arduino IDE is
 a simplified version of C/C++.
\end_layout

\begin_layout Subsubsection
Android SDK
\end_layout

\begin_layout Standard
Android is an open source Operating System developed mainly for smartphones
 and in a row also for tablets with version 3.0 and up.
\end_layout

\begin_layout Subsubsection*
Smartphones
\end_layout

\begin_layout Standard
A smartphone is a mobile phone witch offers much more capabilities such
 as surfing the internet or chatting.
 Basically said, it offers capabilities getting close to an computer.
\end_layout

\begin_layout Standard
The functions can be often extended by so called Apps.
 To make that possible, smartphones have an open api offering functions
 to bring the capabilities to an maximum.
 Any interested developer can download this API and write his own Apps for
 the smartphone based OS.
 The Apps are then OS specific, meaning that opening an IOS application
 in Android would cause an exception.
 There were attempts to make an platform independent api but the specific
 functions can then not be used.
 The developed apps were then distributed via a market system.
 In Android it is the Play Market and the IOS equivalent is the AppStore.
 Interested users can then browse the offered applications by categories
 and download new apps.
 
\end_layout

\begin_layout Subsubsection*
Tablets
\end_layout

\begin_layout Standard
A tablet is basically a portable computer without a keyboard.
 User inputs are made via a stylus or via a touch sensitive screen.
 This defines nothing about the Operating System running on it.
 The first tablets which came on the market had an Desktop OS suplemented
 by a number of drivers and softwares supporting the touchscreen.
 Over time, tablets got their own Operating system deriviates costumized
 and optimized for tablets.
 Of course, there are a view tablets nowadays based on Desktop OS' but these
 are the minority.
 The two main counterparts in the tablet sectors are Android and IOs.
 The prinzip of distributing apps remains the same, but apps have to be
 specially costumized to fit into the tablet user's needs.
\end_layout

\begin_layout Standard
The programming language for developing apps using the specific platform
 api is a dialect of java interpreted from an Dalvik named Interpreter.
 It was originally written by Dan Bornstein and improved over time.
 The apps are compiled to Java bytecode and then converted in the dalvic
 .dex format.
 This format is designed to fit in environments with low storage capabilities
 and limited resources.
\end_layout

\begin_layout Subsubsection*
System architecture
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Android/AndroidCore_system-architecture.jpg
	lyxscale 80
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang naustrian
Android System Architecture 
\begin_inset CommandInset label
LatexCommand label
name "fig:Android System Architecture"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
topmost layer
\series default
, named 
\begin_inset Quotes gld
\end_inset

Application
\begin_inset Quotes grd
\end_inset

 is where apps can be runned using the functions of the Android API.
 There are different API's to choose from but any level is backward compactible.
 Multiple apps were runned simultaniously at the same time.
\end_layout

\begin_layout Standard
The 
\series bold
Application Framework
\series default
 is used for managing the applications, switching between them and offering
 system wide services such as GPS.
\end_layout

\begin_layout Standard
The 
\series bold
Librarys
\series default
 are called if an app needs them.
 Examples for such libraries are OpenGL which is used for creating 2/3D
 view or SQLlight which allows apps to have their own small database locally
 on the device.
\end_layout

\begin_layout Standard
The 
\series bold
Android Runtime
\series default
 interprets the Dalvin .dex files and compiles them into native code.
 It links the libraries and handles tasks like memory management and Exception
 management.
\end_layout

\begin_layout Paragraph
Differences between native and Java bytecode:
\end_layout

\begin_layout Standard
Java bytecode is platform independent, this means that when an Dalvik interprete
r is available on the system, the Java bytecode can be runned.
 So it's possible to write an Dalvik interpreter for Windows or Linux (verweis
 zu interpreter hinzufügen).
 On Compile time, or before the application starts, the Java bytecode will
 be compiled into native code which then can be runned on the processor.
 Normaly, in native code exists no garbage collector and the programmer
 has to detect memory leaks to ensure the stability of the program.
 In Java bytecode, this is done automatically by the interpreter.
\end_layout

\begin_layout Standard
The last layer is the linux kernel layer.
 Due the fact that Android is based on an Linux kernel, system specific
 drivers have to be developed for the system functions such as the Audio
 driver or the power management.
\end_layout

\begin_layout Subsubsection
ADK (Android Open Accessory Development Kit)
\begin_inset CommandInset label
LatexCommand label
name "sub:ADK"

\end_inset


\end_layout

\begin_layout Quotation
The Android 3.1 platform (also backported to Android 2.3.4) introduces Android
 Open Accessory support, which allows external USB hardware (an Android
 USB accessory) to interact with an Android-powered device in a special
 "accessory" mode.
\begin_inset CommandInset citation
LatexCommand cite
key "ADK_A"

\end_inset


\end_layout

\begin_layout Standard
Basically, It allows Android devices to connect to an pheriphial device
 and it offers the ability to communicate with this device.
 In our case, this device is a special Arduino version designed to use with
 an ADK compactible smartphone.
 Once connected, it allows a two way communication between Android and the
 Arduino.
 Due the fact that not every Android smartphone or table is able to establish
 this connection, a number of routines have to be runned through to determine
 it.
\end_layout

\begin_layout Standard
The following function has to be called to get the permission to connect
 to the device:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={C++}"
inline false
status open

\begin_layout Plain Layout

UsbManager mUsbManager = (UsbManager) getSystemService(Context.USB_SERVICE);
\end_layout

\begin_layout Plain Layout

private static final String ACTION_USB_PERMISSION = "com.android.example.USB_PERMIS
SION";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//insert logic
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mPermissionIntent = PendingIntent.getBroadcast(this, 0, new Intent(ACTION_USB_PER
MISSION), 0);
\end_layout

\begin_layout Plain Layout

IntentFilter filter = new IntentFilter(ACTION_USB_PERMISSION);
\end_layout

\begin_layout Plain Layout

registerReceiver(mUsbReceiver, filter);mUsbManager.requestPermission(device,
 mPermissionIntent);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An intent is an abstract description of an operation to be performed.
 The Intent we were using opens a dialog asking for the permission to use
 the usb device.
 We also only want to get Intents which were adressed to us, so we create
 a filter defining that we only want USB permissions.
 The last step is requesting the permission using the global UsbManager
 service.
 To recieve to intent, the following BroadcastReciever has to be created:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={C++}"
inline false
status open

\begin_layout Plain Layout

private static final String ACTION_USB_PERMISSION = "com.android.example.USB_PERMIS
SION"; 
\end_layout

\begin_layout Plain Layout

private final BroadcastReceiver mUsbReceiver = new BroadcastReceiver()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void onReceive(Context context, Intent intent)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		String action = intent.getAction();
\end_layout

\begin_layout Plain Layout

		if (ACTION_USB_PERMISSION.equals(action))
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			synchronized (this)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVIC
E);
\end_layout

\begin_layout Plain Layout

				if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false))
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					if(device != null)
\end_layout

\begin_layout Plain Layout

					{
\end_layout

\begin_layout Plain Layout

						setupConnection();
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				else
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					Log.d(TAG, "permission denied for device " + device);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It reacts on the result of the query and detects if the permission is granted
 or not.
 It logs the result and calls setupConnection to establish the connection.
 setupConnection connects and send one bulk data packet to start the tranfer.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={C++}"
inline false
status open

\begin_layout Plain Layout

UsbInterface intf = device.getInterface(0);
\end_layout

\begin_layout Plain Layout

UsbEndpoint endpoint = intf.getEndpoint(0);
\end_layout

\begin_layout Plain Layout

UsbDeviceConnection connection = mUsbManager.openDevice(device);
\end_layout

\begin_layout Plain Layout

connection.claimInterface(intf, forceClaim);
\end_layout

\begin_layout Plain Layout

connection.bulkTransfer(endpoint, bytes, bytes.length, TIMEOUT);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Technical Solution
\end_layout

\begin_layout Subsubsection
System Architecture
\end_layout

\begin_layout Subsubsection
MCP (Minimal Communication Protocol)
\end_layout

\begin_layout Standard
The “Minimal Communication Protocol” (MCP), is responsible for the communication
 between the Java Server / Android Device and the Arduino MC.
 It consist of the following message types:
\end_layout

\begin_layout Itemize
CallMessage = call a method 
\end_layout

\begin_layout Itemize
LogMessage = to log something 
\end_layout

\begin_layout Itemize
DeviceMessage = represents a device 
\end_layout

\begin_layout Itemize
ResultMessage = returns one or more results from a call
\end_layout

\begin_layout Standard
The Message ID is a system-wide identification number, which is used for
 a uniqueidentification of a message.
\end_layout

\begin_layout Subsubsection*
CallMessage
\end_layout

\begin_layout Standard
An CallMessage is used for calling a Method on the arduino side and also
 on the Java EE side.
 Methods can have n parameters and method overloading is also possible.
 A CallMessage has a simple general structure:
\end_layout

\begin_layout Standard
#<MessageId>:<MessageType>:<DeviceId>:<MethodName>:<parameterlist>;
\end_layout

\begin_layout Standard

\series bold
MessageId
\series default
 is an system wide number an is generated continously.
 Every following message has an higher number as the one before.
 If they are not synchronized, the next time when one of the client sends
 a message, they will synchronice again.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Sequence MCP Message MessageID.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
MCPMessage Sequence Diagram 
\begin_inset CommandInset label
LatexCommand label
name "fig:MCPMessage Sequence Diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
MessageType
\series default
 is an enum describing the type of the message.
 MessageTypes can be CallMessage, LogMessage, DeviceMessage or ResultMessage.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Arduino/MessageType.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
MessageType Enum 
\begin_inset CommandInset label
LatexCommand label
name "fig:MessageType Enum"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
deviceId
\series default
: methods called are specific to the device because not every device has
 the same methods.
 The methods are invoked dynamically at runtime.
 The client can call getDevices to get all available devices with their
 current status.
 Therefore the DeviceId must been set to 0, calling global methods.
\end_layout

\begin_layout Standard
Example Call to get All Devices:
\end_layout

\begin_layout Standard
#25:1:0:getDevices();
\end_layout

\begin_layout Standard

\series bold
MethodName
\series default
 desribes to method which the user wants to call.
 It has to be a Device specific Method.
 If the method could not be invoked, the result will be for example #26:2:3:Meth
od not found;
\end_layout

\begin_layout Standard
There can be as much parameter as the funktion needs allowing funktion overloads
 in this protokoll.
 This means that calling a function with 2 parameters will result in an
 different answer as calling the same funktion with only one.
\end_layout

\begin_layout Standard
Here are some examples for CallMessages:
\end_layout

\begin_layout Standard
#30:1:10:turnOn(); //In this case the device Called is a PowerOutlet.
\end_layout

\begin_layout Standard
#38:1:11:setPosition(200); //sets the position of an rollerblind
\end_layout

\begin_layout Subsubsection*
LogMessage
\end_layout

\begin_layout Standard
Every Home Automation System has his own logging mechanisms because they
 are running 24 hour a day, 7 days a week.
 Aside basic things like a watchdog protection, logging is also implemented
 using the following structure:
\end_layout

\begin_layout Standard
#<MessageId>:<MessageType>:<DeviceId>:<LogLevel>:<LogMessage>;
\end_layout

\begin_layout Standard

\series bold
MessageId
\series default
 is system wide auto generated number described above.
\end_layout

\begin_layout Standard

\series bold
MessageType
\series default
 is in this case 0 for LogMessage.
\end_layout

\begin_layout Standard

\series bold
DeviceId
\series default
 is the Device which autonomiously sends the Log message or the Global Device
 0;
\end_layout

\begin_layout Standard

\series bold
LogLevel
\series default
 is an enum describing the level of the event.
 The enum looks has the following members:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/LogStatusType.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
LogStatusType 
\begin_inset CommandInset label
LatexCommand label
name "fig:LogStatusType"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here are some examples for LogMessages:
\end_layout

\begin_layout Standard
#30:0:10:0:SSR turned On; 
\end_layout

\begin_layout Standard
#38:0:0:2:System reseted;
\end_layout

\begin_layout Subsubsection*
DeviceMessage
\begin_inset CommandInset label
LatexCommand label
name "sub:DeviceMessage"

\end_inset


\end_layout

\begin_layout Standard
DeviceMessages are only sent as answer to an incoming CallMessage calling
 getDevices().
 All available Devices are then sent contiously until every Device's representat
ion is sent.
 The structure of a DeviceMessage:
\end_layout

\begin_layout Standard
#<MessageId>:<MessageType>:<DeviceId>:<DeviceType>:<DeviceName>:<CurrentState>;
\end_layout

\begin_layout Standard

\series bold
MessageId
\series default
 is system wide auto generated number described above.
\end_layout

\begin_layout Standard

\series bold
MessageType
\series default
 is in this case 3 for DeviceMessage.
\end_layout

\begin_layout Standard

\series bold
DeviceId
\series default
 describes the Id of the device which is going to be transmitted.
\end_layout

\begin_layout Standard

\series bold
DeviceType
\series default
 is the type of the device.
\end_layout

\begin_layout Standard

\series bold
DeviceName
\series default
 is a String limited to 40 Charakters describing the device for example
 
\begin_inset Quotes gld
\end_inset

Light Livingroom
\begin_inset Quotes grd
\end_inset

 or 
\begin_inset Quotes gld
\end_inset

all Rollerblinds upstairs
\begin_inset Quotes grd
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
CurrentState
\series default
 is a String consisting of a number of properties formated as propertyname=prope
rtyvalue;propertyName=propertyvalue;.....
 There can be as much properties as needed.
\end_layout

\begin_layout Standard
An Example DeviceMessage would be:
\end_layout

\begin_layout Standard
#2:3:1:Light Livingroom:turnedOn=false;
\end_layout

\begin_layout Subsubsection*
ResultMessage
\end_layout

\begin_layout Standard
After a CallMessage is sent, a ResultMessage is sent to ensure the new state
 of the device.
 ResultMessages are only sent as results to CallMessages not on once own.
\end_layout

\begin_layout Standard
#<MessageId>:<MessageType>:<DeviceId>:<Result>;
\end_layout

\begin_layout Standard

\series bold
MessageId
\series default
 is system wide auto generated number described above.
\end_layout

\begin_layout Standard

\series bold
MessageType
\series default
 is in this case 2 for DeviceMessage.
\end_layout

\begin_layout Standard

\series bold
DeviceId
\series default
 describes the Id of the device where the Method is called, or 0 for the
 global system Device.
\end_layout

\begin_layout Standard

\series bold
Result
\series default
 is a String describing the new state of the Device.
\end_layout

\begin_layout Standard
An Example DeviceMessage would be:
\end_layout

\begin_layout Standard
#201:2:5:Light has been switched off;
\end_layout

\begin_layout Standard
#202:2:5:OK;
\end_layout

\begin_layout Subsubsection
Data model Java EE Server
\end_layout

\begin_layout Subsubsection*
MCP - Activity data model
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MCP-Activity data model"

\end_inset

 shows an overview over the MCP - Activity relation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/Diagram_MCPActivityDataModel.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
MCP-Activity data model
\begin_inset CommandInset label
LatexCommand label
name "fig:MCP-Activity data model"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
MCP Message data model
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Message data model"

\end_inset

 shows an overview over the MCP Message data model.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/Diagram_MessageDataModel.png
	scale 65

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Message data model 
\begin_inset CommandInset label
LatexCommand label
name "fig:Message data model"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Devices data model
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Device data model"

\end_inset

 shows an overview over the device data model.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/Diagram_DevicesOverview.png
	scale 70

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Device data model 
\begin_inset CommandInset label
LatexCommand label
name "fig:Device data model"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Table data
\end_layout

\begin_layout Itemize
ACTIVITY
\end_layout

\begin_layout Itemize
DEVICE
\end_layout

\begin_layout Itemize
DEVICETYPE
\end_layout

\begin_layout Itemize
TASK
\end_layout

\begin_layout Itemize
PROFILE
\end_layout

\begin_layout Itemize
PROFILE_TASK
\end_layout

\begin_layout Itemize
LOG
\end_layout

\begin_layout Subsubsection*
Table ACTIVITY:
\end_layout

\begin_layout Standard
This is one of the central tables on the server, because every message which
 is incoming will be recorded in an activity.
 That's why it's indirectly linked to the DEVICE and LOG tables, because
 these entries will automatically be created by an successfully processed
 activity.
\end_layout

\begin_layout Itemize
BEGINTIME
\end_layout

\begin_deeper
\begin_layout Standard
This property is a date with time and it will be set when the activity is
 created, therefore when the message is received.
\end_layout

\end_deeper
\begin_layout Itemize
ENDTIME
\end_layout

\begin_deeper
\begin_layout Standard
This property is also a date with time and it's set when the activity is
 done processing.
\end_layout

\end_deeper
\begin_layout Itemize
ACTIVITYSTATUS
\end_layout

\begin_deeper
\begin_layout Standard
This is an enum and it's set when the activity is done processing.
\end_layout

\begin_layout Standard
It has the following three types:
\end_layout

\begin_layout Itemize
FINISHED: Is used when the activity is executed without any problems.
\end_layout

\begin_layout Itemize
IN_PROGRESS: Is used when the activity is still in execution.
\end_layout

\begin_layout Itemize
ABORTED: Is used when the activity had an error during the execution.
\end_layout

\end_deeper
\begin_layout Itemize
IP
\end_layout

\begin_deeper
\begin_layout Standard
This is a string and it contains the IP-Adress from where the message came.
\end_layout

\end_deeper
\begin_layout Itemize
STRINGMESSAGE
\end_layout

\begin_deeper
\begin_layout Standard
This is a string and it contains the received message.
\end_layout

\end_deeper
\begin_layout Itemize
INFO
\end_layout

\begin_deeper
\begin_layout Standard
This is a string and contains information what was done and accordingly
 what happened.
\end_layout

\end_deeper
\begin_layout Subsubsection*
Table DEVICE:
\end_layout

\begin_layout Standard
The devices are the representation of the real electronical devices in the
 household.
\end_layout

\begin_layout Itemize
DEVICEID
\end_layout

\begin_deeper
\begin_layout Standard
This is an unique integer which represents a device.
\end_layout

\end_deeper
\begin_layout Itemize
NAME
\end_layout

\begin_deeper
\begin_layout Standard
This is a string and the name of the device.
\end_layout

\end_deeper
\begin_layout Itemize
CURRENTSTATE
\end_layout

\begin_deeper
\begin_layout Standard
This represents the current state of the device in a string.
 Such as if it's on or off.
\end_layout

\end_deeper
\begin_layout Itemize
IP
\end_layout

\begin_deeper
\begin_layout Standard
That's the IP-Adress where the device is located.
 Persisted as a string.
\end_layout

\end_deeper
\begin_layout Itemize
TYPE_ID
\end_layout

\begin_deeper
\begin_layout Standard
This is a foreign key to the DEVICETYPE table.
\end_layout

\end_deeper
\begin_layout Subsubsection*
Table DEVICETYPE:
\end_layout

\begin_layout Standard
In this table are the different types of devices.
\end_layout

\begin_layout Itemize
DEVICETYPE
\end_layout

\begin_deeper
\begin_layout Standard
Represents the type of a device as a string.
\end_layout

\end_deeper
\begin_layout Subsubsection*
Table TASK:
\end_layout

\begin_layout Standard
Represents the tasks which the user creates.
 
\end_layout

\begin_layout Itemize
DAYS
\end_layout

\begin_deeper
\begin_layout Standard
This is a boolean array of seven elements.
 It represents the days on which it should process the task.
\end_layout

\end_deeper
\begin_layout Itemize
TASKTIME
\end_layout

\begin_deeper
\begin_layout Standard
It's the time the task is processed.
\end_layout

\end_deeper
\begin_layout Itemize
TODO
\end_layout

\begin_deeper
\begin_layout Standard
Regulates the actions to do.
 It's persisted as a list of CallMessages.
\end_layout

\end_deeper
\begin_layout Subsubsection*
Table PROFILE:
\end_layout

\begin_layout Standard
Profiles are a bundle of tasks, for making it easy to switch different behaviour
s of the system.
\end_layout

\begin_layout Standard
This table contains:
\end_layout

\begin_layout Itemize
NAME
\end_layout

\begin_deeper
\begin_layout Standard
This is the name of the profile.
\end_layout

\end_deeper
\begin_layout Itemize
ACTIVE
\end_layout

\begin_deeper
\begin_layout Standard
Is a flag for the current active profile.
\end_layout

\end_deeper
\begin_layout Itemize
TASKLIST
\end_layout

\begin_deeper
\begin_layout Standard
Is the list of tasks in the profile.
\end_layout

\end_deeper
\begin_layout Subsubsection*
Table PROFILE_TASK:
\end_layout

\begin_layout Standard
Is the assoziative table between task and profile, because they have a unidirect
ional many to many relationship.
\end_layout

\begin_layout Subsubsection*
Table MCPPlace
\end_layout

\begin_layout Standard
Each Arduino MC is a own MCPPlace.
 A MCPPlace has a place, an IP - Address and a boolean if logging is activated
\end_layout

\begin_layout Itemize
PLACE
\end_layout

\begin_deeper
\begin_layout Standard
Represents the name of this object as a string.
\end_layout

\end_deeper
\begin_layout Itemize
IP
\end_layout

\begin_deeper
\begin_layout Standard
The IP - Address of the Arduino MC, persisted as string.
\end_layout

\end_deeper
\begin_layout Itemize
LOGGINGACTIVATED
\end_layout

\begin_deeper
\begin_layout Standard
A boolean if the server should received log messages from this Arduino.
\end_layout

\end_deeper
\begin_layout Subsubsection*
Table LOG:
\end_layout

\begin_layout Itemize
LOGSTATUS
\end_layout

\begin_deeper
\begin_layout Standard
This is an enum and it has the following three types:
\end_layout

\begin_layout Itemize
NORMAL: A normal log with no exceptional behavior.
\end_layout

\begin_layout Itemize
WARNING: Is used when something unexpected happens.
\end_layout

\begin_layout Itemize
ERROR: Is set when critical things happened.
\end_layout

\end_deeper
\begin_layout Itemize
LOGTEXT
\end_layout

\begin_deeper
\begin_layout Standard
The text of the log.
\end_layout

\end_deeper
\begin_layout Subsection
Description of the system components
\end_layout

\begin_layout Subsubsection
Used Libraries on Arduino
\end_layout

\begin_layout Paragraph
Standart template library
\end_layout

\begin_layout Quotation
The standard C++ library is a collection of functions, constants, classes,
 objects and templates that extends the C++ language providing basic functionali
ty to perform several tasks, like classes to interact with the operating
 system, data containers, manipulators to operate with them and algorithms
 commonly needed.
 
\begin_inset CommandInset citation
LatexCommand cite
key "STL_A"

\end_inset


\end_layout

\begin_layout Standard
The Standart Template library is part of the standart C++ library.
 Normally, as in every newer operating system, the standart template library,
 or STL is ported, available and tested by many different persons.
 Ports for the Atmega systems are instead only rarely available and there
 are only a few wich are nearly bugfree.
 The version wich we included is from 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\backslash
url{http://andybrown.me.uk/ws/2011/01/15/the-standard-template-library-stl-for-avr
-with-c-streams/}}
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Why are we using STL?
\end_layout

\begin_layout Standard
STL provides a number of functions and templates wich are usefull for our
 system.
 If we wouldn't use STL, we would have to port much things by ourselfes
 rather than using this library.
 We used Vectors,Queues, Maps, lists, comparer and iterators.
\end_layout

\begin_layout Minisec
Vectors
\end_layout

\begin_layout Standard
Vectors are basically Arrays which can handle as much elements as free memory
 is available.
 They archive this through reallocating and allocating ahead strategies
 for faster adding of elements.
 Vectors are defined as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

std::vector<int> vec;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As seen, the vector class, as well as the Map and the list class uses templates
 for generating type based classes.
 Instead of, like in .NET generating only one class and then dynamically
 associating them, every new template has to be generated and stored on
 the microcontroller which means that the flash memory used will increase
 rapidly when dealing with different types of arguments.
\end_layout

\begin_layout Standard
Elements can then be added to the vector with one simple line of code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

vec.push_back(3);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The order of the elements will still remain the same, due the fact that
 the element is added at the back.
\end_layout

\begin_layout Standard
In .NET, iterating through elements is done with a foreach loop.
 In C++, it is a little bit different:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={C++}"
inline false
status open

\begin_layout Plain Layout

std::vector<int>::iterator it; 
\end_layout

\begin_layout Plain Layout

for(it=vec.begin();it!=vec.end();it++)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Iterators are used for iterating through the elements by only calling it++.
\end_layout

\begin_layout Minisec
Lists
\end_layout

\begin_layout Standard
Lists are nearly handled as vectors with the exception that the elements
 are stored otherwise.
 List elements are stored with references to the next element wich gives
 it the ability to be faster when iterating through them.
 Lists elements are added the same way and they are deleted the same way.
 They are defined using:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

std::list<int> list;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Iterating through them is also nearly the same as iterating through vectors
 with the exception that the type of the iterator has changed to
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

std::list<int>::iterator it;
\end_layout

\end_inset


\end_layout

\begin_layout Minisec
Maps
\end_layout

\begin_layout Quotation
Maps are a kind of associative container that stores elements formed by
 the combination of a key value and a mapped value.
 
\begin_inset CommandInset citation
LatexCommand cite
key "STL_B"

\end_inset


\end_layout

\begin_layout Standard
In .NET, maps are known as Dictionaries.
 Data in Maps, or Dictionaries is always defined as key-value pair.
 Maps can be defined as described beneath:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

std::map<char*,char*> map;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this variant, the map uses the standart comparer function, comparing
 only by references.
 If the key is, like in our case a char array, comparing them with references
 may result in the wrong value for the key.
 The sulution is provided within the STL library.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct str_cmp { 
\end_layout

\begin_layout Plain Layout

	bool operator()(char const *a, char const *b)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return strcmp(a, b) < 0; 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

std::map<char*,char*,str_cmp> map;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Maps values be accessed and inserted using the following syntax:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

map["key"] = "value"; //if key and value are of type char*
\end_layout

\begin_layout Plain Layout

//or
\end_layout

\begin_layout Plain Layout

map[2] = 32.12; //if key is of type integer and value is of type double
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Iterating through the container is as simple as iterating through lists.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

std::map<int, char*>::iterator itx; for ( itx=deviceMap.begin(); itx != deviceMap.
end(); itx++ ) 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

int key = itx->first;
\end_layout

\begin_layout Plain Layout

char* value = itx->second;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Minisec
Queues
\end_layout

\begin_layout Standard
A Queue is based on the First In First Out (FIFO) prinzip, meaning that
 elements that were enqueued were added to a kind of waiting queue.
 Only the first element can be accessed.
 Defining Queues is pretty straight-forward.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

std::queue<int> queue;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Elements are enqueued using this line of code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

queue.push(3);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once inserted, the first element can be accessed with the line
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int a = queue.pop();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that once this line is finished, it dequeues this element from the
 list.
\end_layout

\begin_layout Subsubsection
MCP Arduino
\end_layout

\begin_layout Standard
The MCP Handling is done in several classes showed in this diagram.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Arduino/MCP Class Diagram.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
MCP Class Diagram Arduino 
\begin_inset CommandInset label
LatexCommand label
name "fig:MCP Class Diagram Arduino"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The base class of all messages is MCP_Message which defines the MessageId
 as well as the MessageType which is in every MessageType the same.
 When the Constructor of the derivied classes are called, this class calls
 at first the base constructor to parse the MessageId and the MessageType.
 Then further prozessing is done using the properties of the classes.
 
\end_layout

\begin_layout Standard
Messages are received in the Connector class.
 With every program loop() iteration, new messages are checked through the
 MessageObserver class.
 This class has the method CheckforMessages() which is called in the main
 loop.
 In the constructor of the MessageObserver class, the observer signs up
 for with his callback method using the following code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

this->connector = Connector::getInstance();
\end_layout

\begin_layout Plain Layout

this->observeSerial=false;
\end_layout

\begin_layout Plain Layout

this->observeEthernet=false;
\end_layout

\begin_layout Plain Layout

connector->initSerial();
\end_layout

\begin_layout Plain Layout

connector->initEthernetShield();
\end_layout

\begin_layout Plain Layout

interpreter = MCP_Interpreter::getInstance();
\end_layout

\begin_layout Plain Layout

listener = new MCP_MessageListener(); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Connector class was built after the singleton pattern because there
 has to be only one instance of this class in the whole system.
 The private properties observeSerial and observeEthernet determine which
 type of connection has to be used.
 The Interpreter class is also a Singleton because there must be one instance
 of this class.
 Messages were processed consective one after another and not at the same
 time.
 MessageListerner is the class which helds the &OnMessageReceived callback.
\end_layout

\begin_layout Standard
Once the Object exists, subscribeListener can be called to register the
 Callback in the Connector class.
 The following Code will be executed:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

void MCP_MessageObserver::subscribeListener()
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	this->connector->setMessageCallback(listener,&MCP_MessageListener::OnMCPMessage
Recieved);
\end_layout

\begin_layout Plain Layout

	Log::serial("subscribing");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the main loop the checkForMessages() Method will be called in every iteration.
\end_layout

\begin_layout Standard
In the background, the Connector class continously checks if messages are
 available.
 If a message has been reveived successfully, the callback is called:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void MCP_MessageListener::OnMCPMessageRecieved(char* msg)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	char* result = MCP_Interpreter::getInstance()->interprete(msg);
\end_layout

\begin_layout Plain Layout

	Connector::getInstance()->sendResult(result); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The callback then calls the MCP_Interpreter instance which interpretes the
 message using the defined format.
 It splitts the messages and depending on the type calls the functions.
 Received types can be LogMessages and CallMessages.
 The prozess of recieving messages and checking them is described beneath.
\end_layout

\begin_layout Standard
Once the CallMessage class exists representing the string message received,
 the device is selected by the DeviceManager class and the method is called
 dynamically.
 The process of calling the methods is described on (TODO: add link)
\end_layout

\begin_layout Standard
If there's an result from the method, this result is sended back by the
 connector class.
 The connector class keeps the last adress used in memory and sends it back
 without the need of specifing the IP Adress or the COM port.
 This Connection is stored in the Connection class determining wich Connectionty
pe used and also which IP-Adress if needed.
 ConnectionType is an enum defining the types ETHERNET, COM or ADK.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Arduino/ConnectionType.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Connection Type 
\begin_inset CommandInset label
LatexCommand label
name "fig:Connection Type"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
MCP Java
\end_layout

\begin_layout Subsection*
MCP messages
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/Diagram_MessageDataModel.png
	scale 65

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
MCP message overview 
\begin_inset CommandInset label
LatexCommand label
name "fig:MCP message overview"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
All message types (CallMessage, DeviceMessage, ResultMessage, LogMessage)
 have a abstract base class Message.
 The base class Message has an id which is set through the singleton GlobalMessa
geID.
 It also contains a MessageType, which is an enum value, therfore the enum
 contains the four message types.
\end_layout

\begin_layout Subsubsection*
DeviceMessage
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/DeviceMessage.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
DeviceMessage class 
\begin_inset CommandInset label
LatexCommand label
name "fig:DeviceMessage class"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every time when the server starts it received all devices.
 To make that possible the DeviceMessage was implemented and therfore it
 represents a device.
 It has the same properties as a device except for the IP - Address which
 it gets from the socket.
\end_layout

\begin_layout Subsubsection*
CallMessage
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/CallMessage.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
CallMessage class 
\begin_inset CommandInset label
LatexCommand label
name "fig:CallMessage class"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
A CallMessage will be send to the Arduino MC for calling a method.
 The deviceId is used to determine the corresponding device and the methodName
 is the method which will be called.
 If the CallMessage is global then a '0' will be used a deviceId, for example
 the method 'getDevices'.
 If the method has any arguments then they are in the list of string parameter.
\end_layout

\begin_layout Subsubsection*
ResultMessage
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/ResultMessage.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
ResultMessage class
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every time when the server sends a CallMessage to the Arduino MC it will
 send a ResultMessage back.
 Again the deviceId is used to determine the corresponding device and if
 it's global '0' is used.
 The string result contains the result which can be 'true' if it's only
 sent as an acknowledgment of receipt or something like 'temperature=21'
 if it's the value from a sensor.
\end_layout

\begin_layout Subsubsection*
LogMessage
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/LogMessage.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
LogMessage class
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The LogMessage is used to log events, errors, etc.
 The logText contains the message what happened and the status is a value
 of an enum which can take the values 'ERROR', 'WARNING' or 'NORMAL'.
 The deviceId is used to determine the corresponding device and if it's
 global '0' is used.
\end_layout

\begin_layout Subsubsection*
GlobalMessageID
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/GlobalMessageID.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
GlobalMessageID class
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The GlobalMessageID is a singleton class and it's used to distribute the
 ids to the messages.
 If message is created it will automatically get an id from this class.
\end_layout

\begin_layout Subsubsection*
MessageTypeEnum
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/MessageTypeEnum.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
MessageTypeEnum
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This enum contains all message types.
 The message type is sent within the string which the socket receives and
 that's why the server is able to create the right message out of this string.
\end_layout

\begin_layout Subsection*
MCP communication
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/Diagram_MCPActivityDataModel.png
	scale 70

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
MCP communication overview 
\begin_inset CommandInset label
LatexCommand label
name "fig:MCP communication overview"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The communication between the server and an Arduino MC begins at the bottom
 right corner of the diagram (
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MCP communication overview"

\end_inset

).
 The MCPSocketListener class has a SocketServer which listens on port 13316
 and of course the class runs in a seperate thread.
 When this class gets a message, it creates a new MCPSocketReader, also
 in a seperate thread.
\end_layout

\begin_layout Standard
Now the MCPSocketReader gets/reads all messages from the socket and creates
 for each message an activity.
 The activity class is made for statistic usages, but it's main aspect is
 for creating the message from the stringMessage through the ActivityListener
 class.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},breaklines=true,language=Java,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

//Reads the first line from the socket
\end_layout

\begin_layout Plain Layout

line = reader.readLine();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while (line != null && reader != null) {
\end_layout

\begin_layout Plain Layout

	//Sets the GlobalMessageID from the incoming message
\end_layout

\begin_layout Plain Layout

	GlobalMessageID.getInstance().setId(Long.parseLong((line.substring(1)).split(":")[0]
));
\end_layout

\begin_layout Plain Layout

	//Creates a new activity with the ip from the sender, the beginTime as
 timestamp, sets that the activity is in progress and the stringMessage
\end_layout

\begin_layout Plain Layout

	activity = new Activity(clientIp, new Timestamp(new Date().getTime()), ActivityS
tateEnum.IN_PROGRESS, line);
\end_layout

\begin_layout Plain Layout

	//Persists the activity
\end_layout

\begin_layout Plain Layout

	activityFacade.create(activity);
\end_layout

\begin_layout Plain Layout

	//Reads the next line
\end_layout

\begin_layout Plain Layout

	line = reader.readLine();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

//If the reader isn't closed yet, then the reader will be closed
\end_layout

\begin_layout Plain Layout

if (reader != null) reader.close();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
Before the activity gets perstited into the database, the method 'prePersistActi
vity(Activity activity)' in the ActivityListenter class gets called because
 of the @EntityListeners(ActivityListener.class) annotation in the Activity
 class and the @PrePersist annotation in the ActivityListener class.
\end_layout

\begin_layout Standard
In the ActivityListener class the stringMessage will be casted to a CallMessage,
 ResultMessage, LogMessage or DeviceMessage.
 If it's a DeviceMessage then a device will be created and persisted into
 the database.
 If the stringMessage is a ResultMessage the corresponding device gets it's
 state updated.
 If it's a LogMessage then a Log will be created and will get persisted
 into the database.
 And finally if it's a CallMessage nothing happens, because the server shouldn't
 reveice one.
 The activity info propertie gets updated accordingly in all situations.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},breaklines=true,language=Java,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

@PrePersist
\end_layout

\begin_layout Plain Layout

private void prePersistActivity(Activity activity) {
\end_layout

\begin_layout Plain Layout

	//Getting the Facades
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Converts the stringMessage to a Message
\end_layout

\begin_layout Plain Layout

	Message message = getMessage(activity.getStringMessage());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (message != null) {
\end_layout

\begin_layout Plain Layout

		Device device;
\end_layout

\begin_layout Plain Layout

		//Check which message type it is
\end_layout

\begin_layout Plain Layout

		switch (message.getMessageType().ordinal()) {
\end_layout

\begin_layout Plain Layout

			case 0: //DeviceMessage
\end_layout

\begin_layout Plain Layout

				//A device will be created and persisted into the database
\end_layout

\begin_layout Plain Layout

				//The activity will be set to finished, an endtime will be set and the
 info will be updated
\end_layout

\begin_layout Plain Layout

				break;
\end_layout

\begin_layout Plain Layout

			case 1: //CallMessage
\end_layout

\begin_layout Plain Layout

				//The server shouldn't receive a CallMessage, therfore the activity
 will be set accordingly
\end_layout

\begin_layout Plain Layout

				activity.setEndTime(new Timestamp(new Date().getTime()));
\end_layout

\begin_layout Plain Layout

				activity.setActivityState(ActivityStateEnum.ABORTED);
\end_layout

\begin_layout Plain Layout

				activity.setInfo("RCSServer shouldn't get a CallMessage.");
\end_layout

\begin_layout Plain Layout

				break;
\end_layout

\begin_layout Plain Layout

			case 2: //ResultMessage
\end_layout

\begin_layout Plain Layout

				//The state of the corresponding device will be updated
\end_layout

\begin_layout Plain Layout

				//The activity will be set to finished, an endtime will be set and the
 info will be updated
\end_layout

\begin_layout Plain Layout

				break;
\end_layout

\begin_layout Plain Layout

			case 3: //LogMessage
\end_layout

\begin_layout Plain Layout

				//A Log will be created and persisted into the database
\end_layout

\begin_layout Plain Layout

				//The activity will be set to finished, an endtime will be set and the
 info will be updated
\end_layout

\begin_layout Plain Layout

				break;
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		activity.setEndTime(new Timestamp(new Date().getTime()));
\end_layout

\begin_layout Plain Layout

		activity.setActivityState(ActivityStateEnum.ABORTED);
\end_layout

\begin_layout Plain Layout

		activity.setInfo("Invalid message!");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
The MCPSocketWriter is created when the server sends a message.
 The message will be send in a seperate thread, because the destination
 may be offline and this causes a exception and if it wouldn't be sent in
 a seperate thread the whole program would stop for the duration of a timeout.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},breaklines=true,language=Java,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

public class MCPSocketWriter extends Thread {
\end_layout

\begin_layout Plain Layout

	private String ip;
\end_layout

\begin_layout Plain Layout

	private Message message;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public MCPSocketWriter(String ip) {
\end_layout

\begin_layout Plain Layout

		this.ip = ip;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void send(Message message) {
\end_layout

\begin_layout Plain Layout

		this.message = message;
\end_layout

\begin_layout Plain Layout

		this.start();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public void run() {
\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			//Creates the socket to the destination
\end_layout

\begin_layout Plain Layout

			Socket socket = new Socket(InetAddress.getByName(ip), 13316);
\end_layout

\begin_layout Plain Layout

			//Creates the writer
\end_layout

\begin_layout Plain Layout

			PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);
\end_layout

\begin_layout Plain Layout

			//Stops for 20ms because if messages are sent without timeout, then they
 may be lost
\end_layout

\begin_layout Plain Layout

			Thread.sleep(20);
\end_layout

\begin_layout Plain Layout

			//Sends the message
\end_layout

\begin_layout Plain Layout

			writer.println(message.toString());
\end_layout

\begin_layout Plain Layout

			//Closes the writer and socket
\end_layout

\begin_layout Plain Layout

			writer.close();
\end_layout

\begin_layout Plain Layout

			socket.close();
\end_layout

\begin_layout Plain Layout

		} catch (Exception ex) {
\end_layout

\begin_layout Plain Layout

			System.out.println("MCPSocketWriter.send: " + ex.toString());
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Control Apps Arduino
\end_layout

\begin_layout Paragraph
Control App Structure
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Arduino/Device Structure Arduino.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Device Structure Arduino 
\begin_inset CommandInset label
LatexCommand label
name "fig:Device Structure Arduino"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every ControlApp consists of 0 to n Actors and 0 to n sensors.
 Actor classes generally offer methods to invoke actions, while sensors
 generally are used to monitor the environment conditions.
 ControlApps are the interface to the Arduino part.
 They offer methods wich can be called from outside the Arduino system different
 from actors and sensors wich can only be invoked within the system.
 The deeper the Actor or the Sensor is in the hirarchie, the more hardware
 based is it.
 This simple Example shows how this paradigm can be used.
\end_layout

\begin_layout Standard
Every ControlApp, every Sensor and every Actor are administered by the DeviceMan
ager Singleton Class.
 Any App must derive from the base class named ControlApp.
 In these class, general methods are defined which have to be implemented.
 They were needed for communicating with the Environment.
 These methods are:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={C++}"
inline false
status open

\begin_layout Plain Layout

	virtual char* callMethod(String methodName,std::vector<char*> params) =
 0;
\end_layout

\begin_layout Plain Layout

	virtual bool doWork() =0;
\end_layout

\begin_layout Plain Layout

	virtual std::map<char*,char*> getProperties()=0;
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Calling a method using jumptables
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Due to the fact that were are working on a very low level hardware and software
 system, reflection is not available.
 Generally in C++ reflection is available with different Librarys such as
 RTTI (Run-Time Type Information).
 Porting would hardly be possible because of the limited resources on the
 Arduino System.
 So instead of dynamically calling the method, there is a little workaround
 which we implemented.
 Every Control App has to implement a method named callMethod accepting
 two paramters, the name of the method to be called and the params.
 How this method is implemented inside, does not matter, but in fact, there
 is only one solution which suits best for this operation.
 Making a jumpTable improves the way a method is called compared to simple
 if statements.
 Once such a table is implemented, only the methodname and the pointer to
 the method has to be added.
 Here is an example implementation of such an method:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={C++}"
inline false
status open

\begin_layout Plain Layout

char* SensorDevice::callMethod(String methodName,std::vector<char*> params)
 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	for(int i = 0;i<GetArrayLength(functionNames);i++)
\end_layout

\begin_layout Plain Layout

		{ 
\end_layout

\begin_layout Plain Layout

			if(functionNames[i] == methodName)
\end_layout

\begin_layout Plain Layout

			{ 
\end_layout

\begin_layout Plain Layout

				return (this->*functionArray[i])(params);
\end_layout

\begin_layout Plain Layout

			} 
\end_layout

\begin_layout Plain Layout

		} 
\end_layout

\begin_layout Plain Layout

	return METHOD_NAME_NOT_FOUND; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code above iterates through the functionNames array and if it finds
 the same name as the one passed as a parameter, it calls the appropriate
 Method using the jumpTable named functionArray.
 In the class file, the following example definitons have been made:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={C++}"
inline false
status open

\begin_layout Plain Layout

typedef char* (SensorDevice::*ptMember)(std::vector<char*>);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ptMember functionArray[3] = {&SensorDevice::getLuminosity,&SensorDevice::getTemp
erature,&SensorDevice::getMovementRaw};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

char* functionNames[3] = {"getBrightness","getTemperature","getMovement"};
 
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Multitasking on Arduino hardware
\end_layout

\begin_layout Standard
Due the fact that multitasking is not available on the Arduino board, we
 implemented a simple but effective method which allows all Control Apps
 to do their work at nearly the same time if needed.
 The idea behind the concept is that every class which wants to run simultanious
ly has to implement the doWork Method.
 Internally, this method has certain entry point where data is processed.
 Using this structure a cooperative multi tasking system is established.
 At any time while the system is running, Apps can add themselve to a Working
 Queue using the following code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WorkQueue::getInstance()->add(this);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this working queue, all the doWork methods of the subscribed Apps were
 called continously one after another.
 The only thing which must'n be done by any App is the use of blocking functions
 such as sleep.
 If, for example the App wants to run through some lines of code every one
 second, it has to use the millis function which is defined By the Arduino
 framework.
 Using this technique, the doWork methods are called without much delay.
 The implementation of the Workqueue class allows users to remove themselves
 at any time they want by returning false in the doWork Method or by calling
 WorkQueue::remove(this);
\end_layout

\begin_layout Subparagraph
Getting all the relevant properties for simple data exchange
\end_layout

\begin_layout Standard
At the client, on startup, every property has to be retrieved by sending
 Callmessages.
 In further consequence, the UI system may doesn't react any more because
 sending, computing and retrieving the messages costs time.
 So we defined that every Control App also has to have the availability
 to retrieve all data from the device at once.
 By default, when all the available Devices are sent, these informations
 are also sended.
 It is implemented using the Method getProperties.
 It returns a map of variables which are relevant for the UI.
 An example implementation could be as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

std::map<char*,char*> SensorDevice::getProperties()
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	std::map<char*,char*> props;
\end_layout

\begin_layout Plain Layout

	temp = (char*)malloc(20);
\end_layout

\begin_layout Plain Layout

	sprintf(temp,"%s",this->getTemperature());
\end_layout

\begin_layout Plain Layout

	props["temperature"] = temp;
\end_layout

\begin_layout Plain Layout

	return props; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sending Control App information
\end_layout

\begin_layout Standard
When the client starts up, it does not know wheter how many devices are
 available or what devices these are.
 So we implemented a global method called getDevices wich is able to iterate
 through all devices and send back their specific informations.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Synchronizing Devices.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Synchronizing Devices 
\begin_inset CommandInset label
LatexCommand label
name "fig:Synchronizing Devices"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the Callmessage is sent, a number of DeviceMessages are sent as an
 information.
 The last messages is in any case a ResultMessage determining if the transfer
 was successfull or not.
 Informations concerning DeviceMessages can be found at 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:DeviceMessage"

\end_inset

.
\end_layout

\begin_layout Paragraph
Flow Diagram
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Arduino Message Diagram.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Arduino Message Diagram 
\begin_inset CommandInset label
LatexCommand label
name "fig:Arduino Message Diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once a message has been received, the singleton class MCP_Interpreter is
 called.
 This class basically contains the handling of messages in runtime.
 The interprete method returns the result received from the different ControlApp
s or the exception messages when for example a device was not found.
 At first, this method splits the incoming message, prooves if the message
 is a CallMessage and then it creates a Call_Message instance based on this
 data.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

std::vector<char*> elems; StringUtility::split(mcpMessage,":#;()",elems);
\end_layout

\begin_layout Plain Layout

char t = elems[1][0];
\end_layout

\begin_layout Plain Layout

MCP_Message::MessageType type = (MCP_Message::MessageType) (t - '0');
\end_layout

\begin_layout Plain Layout

if(type == MCP_Message::Call) { return this->handleCallMessage(elems);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Call_Message callmsg(elems);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now the retrieved deviceId is prooved and when 0 is passed, global methods
 were executed.
 If a DeviceId greater than 0 is passed, the DeviceManager's method getDeviceByI
d is called with the deviceId as Parameter.
 If the Device is found, the callMethod function is called which is described
 above.
 It returns an result which is then immediatly passed back and sended to
 the requesting instance.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

Device *dev = DeviceManager::getInstance()->getDeviceById(callmsg.getDevId());
 
\end_layout

\begin_layout Plain Layout

char* erg = NULL; return dev->callMethod(callmsg.getMethodName(),callmsg.getParams
()); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the code above is simplyfied to show the general procedure.
\end_layout

\begin_layout Subparagraph
Storing and Saving
\end_layout

\begin_layout Standard
Due to the fact that after every shutdown have to be loaded again on the
 next startup, we implemented a system used for persisting Control Apps,
 Actors and Sensors.
 Saving of classes was a straightfoward matter, but loading them again without
 the use of reflection was far more complicated.
 We implemented a reflection like system for generating instances of classes
 using templating and factory design patterns.
 We created one singleton class named UnifiedFactory which abstracted the
 loading of classes.
 In order to implement a method named generateClassFromName, we also implemented
 a interface named IPersistable which every Control App, Actor and Sensor
 should implement.
 It is defined as followed:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

class IPersistable { 
\end_layout

\begin_layout Plain Layout

public: 
\end_layout

\begin_layout Plain Layout

	virtual std::map<char*,char*> save()=0;
\end_layout

\begin_layout Plain Layout

	virtual IPersistable* load(std::map<char*,char*,str_cmp>)=0;
\end_layout

\begin_layout Plain Layout

	virtual int getId()=0;
\end_layout

\begin_layout Plain Layout

	virtual char* getClassName()=0; 
\end_layout

\begin_layout Plain Layout

}; 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When implementing this interface, every class has its own class name which
 can be retrieved by calling getClassName.
 This allows us to choose which template object should be instanciated.
 Templates were instanced with the following line of code:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

IPersistable* persistableClassArray[9] = { new SensorDevice(), new SolidStateRel
ay(), new PowerOutlet(), new Heater(), new TemperatureSensorPhidget(), new
 PrecisionLightSensorPhidget(), new Light(), new Rolladen(), new Fan()};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It makes no difference wheter these classes are Actors or Sensors, it only
 bothers that they implement the IPersistable interface.
 When generateClassFromName with the methodname and the instancing parameters
 is called, the system iterates through the array and check if these class
 is available for instanciation.
 If the class is found, the load method is called.
 The load method mustn't return a pointer to his own object because the
 objects instanciated here are only templates which must not be able to
 live outside this scope.The generateClassFromName function is defined as
 follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Persistable* UnifiedFactory::generateClassFromName(char* className,std::map<char
*,char*,str_cmp> params);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the object is sucessfully referenced, it is passed back to the DeviceManager
 Class.
 Otherwise NULL will be passed back.
\end_layout

\begin_layout Standard
An example impementation of load would be:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

Rolladen* rolladen = new Rolladen(StringUtility::atoi(map["position"]));
\end_layout

\begin_layout Plain Layout

rolladen->setId(StringUtility::atoi(map["id"])); rolladen->setSSRUp((SolidStateR
elay*)DeviceManager::getInstance()->getActorById(StringUtility::atoi(map["ssrUpI
d"]))); rolladen->setSSRDown((SolidStateRelay*)DeviceManager::getInstance()->get
ActorById(StringUtility::atoi(map["ssrDownId"]))); 
\end_layout

\begin_layout Plain Layout

return rolladen;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The StringUtility class offers basic methods for working with char arrays,
 for example atoi which converts char arrays to integer.
 The actors needed for the Rollerblinde are retrieved by calling getActorById
 with the saved Id of the actor.
 The actor itself is not saved, instead the id of it is saved and loaded
 then again using the DeviceManager class.
 The device itself must ensure that the actor exists and is properly loaded.
\end_layout

\begin_layout Standard
There were two methods which handle the saving and the loading of all Actors,
 Sensors and ControlApps in the Devicemanager class called writeToSdCard
 and readFromSdCard accepting no arguments.
\end_layout

\begin_layout Minisec
readFromSdCard
\end_layout

\begin_layout Standard
The readFromSdCard Method calls the private load method with three different
 parameters as shown below:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if(-1==this->load("Actors.mcp",&actorMap)) return -1;
\end_layout

\begin_layout Plain Layout

if(-1==this->load("Sensors.mcp",&sensorMap)) return -1;
\end_layout

\begin_layout Plain Layout

if(-1==this->load("Devices.mcp",&deviceMap)) return -1;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
the load Method basically opens the file wich is passed as a parameter.
 It then iterates trough the map passed as a reference.
 Due the fact that Actors,Sensors and ControlApps are all implementing the
 IPersistable Interface, the load method casts the passed map to a persistablema
p using the following syntax:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

std::map<int,IPersistable*,ltDev>* persistableMap = static_cast<std::map<int,
 IPersistable*,ltDev> *>(ptr);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Static casts are cast between pointers of the same hirarchie.
 It isn't ensured that the cast is successfull, but one parameter must derive
 the other parameter.
 In our case, Actor* derives from IPersistable.
 Then, the lines are read and object are generated using the UnifiedFactory
 class.
\end_layout

\begin_layout Minisec
writeToSdCard
\end_layout

\begin_layout Standard
The writeToSdCard method calls the private persist method with different
 parameters:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if(-1==this->persist("Actors.mcp",&actorMap)) return -1;
\end_layout

\begin_layout Plain Layout

if(-1==this->persist("Sensors.mcp",&sensorMap)) return -1;
\end_layout

\begin_layout Plain Layout

if(-1==this->persist("Devices.mcp",&deviceMap)) return -1;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The persist method casts the pointer with an static_cast to a persistable
 map and iterates through the map.
 Every element's save method is called and the result is concatinated to
 one string wich is saved afterwards.
 The file wich is passed by the parameter is opened and every device is
 saved.
\end_layout

\begin_layout Minisec
Store Format 
\end_layout

\begin_layout Standard
The different IPersistable Classes are stored in a simple format with the
 following structure:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<ClassName>
\end_layout

\begin_layout Plain Layout

<parameterKey>=<parameterValue>|<parameterKey>=<parameterValue>|<parameterKey>=<
parameterValue>|...
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Steps for developing own Control Apps
\end_layout

\begin_layout Standard
First of all, a new class has to be created as an Android library.
 That means that the containing folder is named identically to the class
 which has to be created and the the folder is in the librarys path wich
 can be customiced with the Arduino IDE.
 Once the class is is created, it has to be derivied from the ControlApp
 base class and the following methods have to be declared and implemented:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

virtual char* callMethod(String,std::vector<char*>) = 0;
\end_layout

\begin_layout Plain Layout

virtual bool doWork() =0; virtual std::map<char*,char*> save()=0;
\end_layout

\begin_layout Plain Layout

virtual IPersistable* load(std::map<char*,char*,str_cmp>)=0;
\end_layout

\begin_layout Plain Layout

virtual char* getClassName()=0; virtual std::map<char*,char*> getProperties()=0;
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
How the different methods are implementes is described above.
\end_layout

\begin_layout Standard
The second step is that once the implementation is finished to add this
 class to the Unifiedfactories perstistableClassArray properties.
 
\end_layout

\begin_layout Subsubsection
Devices Java Side
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/Diagram_DevicesOverview.png
	scale 80

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Devices overview 
\begin_inset CommandInset label
LatexCommand label
name "fig:Devices overview"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Devices overview"

\end_inset

 shows how the devices are connected.
 In the following pages every class with it's structure is described.
\end_layout

\begin_layout Subsubsection*
DeviceType
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/DeviceType.png

\end_inset

Again th
\begin_inset Caption

\begin_layout Plain Layout
DeviceType class 
\begin_inset CommandInset label
LatexCommand label
name "fig:DeviceType class"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The DeviceType contains the device type as a string, for example 
\begin_inset Quotes gld
\end_inset

RollerBlind
\begin_inset Quotes grd
\end_inset

, etc.
 It is essential, that this string equals the class name, because in the
 UI the form for each device is loaded with this string.
 It also contains a HashMap for the methods, which should be available for
 the tasks, explained later.
 The public methods are the constuctors and the getters and setters for
 the properties.
\end_layout

\begin_layout Subsubsection*
Device
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/Device.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Device class 
\begin_inset CommandInset label
LatexCommand label
name "fig:Device class"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The device class is the base class for each device.
 Normally it should be abstract, but it isn't so because this class is used
 to persist them into the database and therefore it's needed to instantiate
 it.
 Each device has an unique id, an IP - Address, a name and a device type.
 Each device which is derived from this class has it's own states and they
 are persisted in this class as currentState.
\end_layout

\begin_layout Subsubsection*
AlarmSystem
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/AlarmSystem.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
AlarmSystem class 
\begin_inset CommandInset label
LatexCommand label
name "fig:AlarmSystem class"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The AlarmSystem has an alarm as integer with the value '0' or '1', which
 represents if it is activated or not.
 The state can take the values 'on' or 'off' and therfore represents if
 the AlarmSystem is turned on or turned off.
 The subscription declares if the server will receive an alarm or not and
 can take the values 'subscribed' or 'unsubscribed'.
\end_layout

\begin_layout Subsubsection*
Fan
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/Fan.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Fan class 
\begin_inset CommandInset label
LatexCommand label
name "fig:Fan class"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The integer value temperature is responsible for the temperature condition,
 which means that if the temperature of the sensor exceeds this value the
 fan will be turned on.
 The state can take the values 'on' or 'off' and therfore represents if
 the Fan is turned on or turned off.
\end_layout

\begin_layout Subsubsection*
Light
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/Light.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Light class 
\begin_inset CommandInset label
LatexCommand label
name "fig:Light class"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The data structure of the light is nearly the same as the structure of the
 Fan.
 The only differnce is, that the Light doesn't use a temperature but a brightnes
s for it's condition.
\end_layout

\begin_layout Subsubsection*
Heater
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/Heater.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Heater class 
\begin_inset CommandInset label
LatexCommand label
name "fig:Heater class"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The data structure of the Heater is equivalent to the data structure of
 the Fan.
\end_layout

\begin_layout Subsubsection*
PowerOutlet
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/PowerOutlet.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
PowerOutlet class 
\begin_inset CommandInset label
LatexCommand label
name "fig:PowerOutlet class"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only propertie that a PowerOutlet has, is a state, which can take the
 values 'on' or 'off'.
\end_layout

\begin_layout Subsubsection*
SensorDevice
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/SensorDevice.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
SensorDevice class 
\begin_inset CommandInset label
LatexCommand label
name "fig:SensorDevice class"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The SensorDevice represents a light sensor and a temperature sensor.
 It can't do any actions and only shows the temperature and the brightness
 of the sensors.
\end_layout

\begin_layout Subsubsection*
RollerBlind
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/RollerBlind.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
RollerBlind class 
\begin_inset CommandInset label
LatexCommand label
name "fig:RollerBlind class"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The RollerBlind has got a position at which he is currently.
 The brightness represents the brightness condition and if the brightness
 of the sensor falls below this condition the RollerBlind moves down.
\end_layout

\begin_layout Subsubsection
Tasks & Profiles
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/Diagram_ProfileTaskOverview.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Profile-Task overview 
\begin_inset CommandInset label
LatexCommand label
name "fig:Profile-Task overview"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To reach a certain automation in our system profiles and tasks are used.
\end_layout

\begin_layout Standard
For example profiles are 'Holiday profile' or a 'Work profile'.
 These profiles can be activated (boolean active) and they have a list of
 tasks which should be processed if it's active.
 This happens in the ProfileScheduler:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/ProfileSchedulerFULL.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
ProfileScheduler 
\begin_inset CommandInset label
LatexCommand label
name "fig:ProfileScheduler"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ProfileScheduler contains the method 'scheduleActiveProfiles()' with
 the @Schedule(hour = "*", minute = "*/1", persistent = true) annotation,
 which means that it every hour every single minute this method is called.
 What happens in this method you can see below in the code:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},breaklines=true,language=Java,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

@Schedule(hour = "*", minute = "*/1", persistent = true)
\end_layout

\begin_layout Plain Layout

private void scheduleActiveProfiles() throws ParseException, InterruptedExceptio
n {
\end_layout

\begin_layout Plain Layout

	//Retrieve all profiles from the database
\end_layout

\begin_layout Plain Layout

	List<Profile> profileList = profileFacade.findActiveProfiles();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (profileList != null && !profileList.isEmpty()) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		for (Profile profile : profileList) {
\end_layout

\begin_layout Plain Layout

			//Get the current time
\end_layout

\begin_layout Plain Layout

			Timestamp timestamp = new Timestamp(Calendar.getInstance().getTime().getTime());
\end_layout

\begin_layout Plain Layout

			//Retrieve all tasks from the current profile
\end_layout

\begin_layout Plain Layout

			List<Task> taskList = profile.getTaskList();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			for (Task task : taskList) {
\end_layout

\begin_layout Plain Layout

				//Check if the current time and day equals with these from the task
\end_layout

\begin_layout Plain Layout

				if (task.getDays()[timestamp.getDay()] == true
\end_layout

\begin_layout Plain Layout

					&& task.getHourTime() == timestamp.getHours()
\end_layout

\begin_layout Plain Layout

					&& task.getMinuteTime() == timestamp.getMinutes()) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

					//Create a new MCPSocketWriter with the destination of the task
\end_layout

\begin_layout Plain Layout

					MCPSocketWriter writer = new MCPSocketWriter(task.getDestinationIp());
\end_layout

\begin_layout Plain Layout

					//Send the CallMessage
\end_layout

\begin_layout Plain Layout

					writer.send(task.getTodo());
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The task also has to know to which profile it belongs, because it mustn't
 be deleted if a profile uses it.
\end_layout

\begin_layout Subsubsection
SOAP Webservice
\end_layout

\begin_layout Standard
The SOAP web service is built up quite simple:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/RCSServer/classes/RCSWebService.png

\end_inset

CallMessage
\begin_inset Caption

\begin_layout Plain Layout
SOAP WebService 
\begin_inset CommandInset label
LatexCommand label
name "fig:SOAP WebService"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the code below you are able to see the RCSWebService class:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},breaklines=true,language=Java,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

@WebService(serviceName = "RCSWebService")
\end_layout

\begin_layout Plain Layout

public class RCSWebService {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@EJB
\end_layout

\begin_layout Plain Layout

	private DeviceFacade deviceFacade;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	@WebMethod(operationName = "getDeviceByName")
\end_layout

\begin_layout Plain Layout

	public Device getDeviceByName(@WebParam(name = "name") String name) {
\end_layout

\begin_layout Plain Layout

		return deviceFacade.findbyName(name);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	@WebMethod(operationName = "getDeviceById")
\end_layout

\begin_layout Plain Layout

	public Device getDeviceById(@WebParam(name = "deviceId") int deviceId)
 {
\end_layout

\begin_layout Plain Layout

		return deviceFacade.findbyDeviceId(deviceId);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see this code is really simple, it only returns the requested
 device.
 And at the client you have to use the @WebServiceRef annotation on the
 device because this makes it possible to invoke a SOAP web service.
\end_layout

\begin_layout Quotation

\shape italic
\begin_inset Quotes gld
\end_inset

With the WSDL and some tools to generate the Java stubs, you can invoke
 a web service.
 Invoking a web service is similar to invoking a distributed object with
 RMI.
 Like RMI, JAX-WS enables the programmer to use a local method call to invoke
 a service on another host.
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "JavaEE"

\end_inset


\end_layout

\begin_layout Subsubsection
Web Interface
\end_layout

\begin_layout Standard
The web interface is built up into tabs, which are seperated in a Devices,
 Profile & Task, Settings and Log tab.
\end_layout

\begin_layout Subsection*
Devices
\end_layout

\begin_layout Standard
In the devices tab the devices are listed in a table as shown below:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/pictures/RCSServer/devicesTable.tiff
	scale 40

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Devices table 
\begin_inset CommandInset label
LatexCommand label
name "fig:Devices table"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
Each device in this table is selectable and if a device is selected the
 region beside the table will be updated.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Subsubsection*
RollerBlind
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/pictures/RCSServer/webinterface-rollerblind.tiff
	scale 70

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Webinterface RollerBlind 
\begin_inset CommandInset label
LatexCommand label
name "fig:Webinterface RollerBlind"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
In the first row the rollerblind position can be set with the slider and
 the button.
 The second row shows the current brightness.
 In the third row the user is able to set/remove the brightness condition
 of the rollerblind.
\end_layout

\begin_layout Standard
The rollerblind is made with a primefaces slider and this slider is connected
 per JavaScript/CSS/HTML to the rollerblind image beside it.
 The code below shows how this exactly works:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},breaklines=true,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

#rollerblind.js
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function rollerblind_moveToPosition(sliderTextId, imgInsideId) {
\end_layout

\begin_layout Plain Layout

	//Gets the inner image of the rollerblind
\end_layout

\begin_layout Plain Layout

	var imgInside = document.getElementById(imgInsideId);
\end_layout

\begin_layout Plain Layout

	//Gets the hidden inputtext for the slider
\end_layout

\begin_layout Plain Layout

	var sliderText = document.getElementById(sliderTextId);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Calculates the position at which the image should be
\end_layout

\begin_layout Plain Layout

	var position = parseFloat(1000 - sliderText.value);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Calculates the the highest position that the image may be
\end_layout

\begin_layout Plain Layout

	var max = parseFloat(parseInt(imgInside.height) * 19 / 20 * (-1));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Looks if the position is in the expected range
\end_layout

\begin_layout Plain Layout

	if (position <= 1000 && position >= 0) {
\end_layout

\begin_layout Plain Layout

		//Sets the top position of the inner image of the rollerblind
\end_layout

\begin_layout Plain Layout

		imgInside.style.top = max * (1 - (position / 1000)) + 'px';
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#RollerBlind.xhtml
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

<div id="rollerblind#{deviceController.selectedDevice.deviceId}"
\end_layout

\begin_layout Plain Layout

class="standard"
\end_layout

\begin_layout Plain Layout

style="width: 140px; height: 150px; position: relative;">
\end_layout

\begin_layout Plain Layout

	<div id="divOutside#{deviceController.selectedDevice.deviceId}"
\end_layout

\begin_layout Plain Layout

	style="position: relative; width: 120px; height: 150px; float: left;">
\end_layout

\begin_layout Plain Layout

		<img id="imgOutside#{deviceController.selectedDevice.deviceId}"
\end_layout

\begin_layout Plain Layout

		src="pictures/rollerblind_outside.jpg"
\end_layout

\begin_layout Plain Layout

		style="position: absolute; width: 120px;" />
\end_layout

\begin_layout Plain Layout

			<div id="divInside#{deviceController.selectedDevice.deviceId}"
\end_layout

\begin_layout Plain Layout

			style="position: relative; overflow: hidden; top: 27px; left: 8px; width:
 104px; height: 124px;">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				//When the image is loaded the JavaScript method will be called and
 the right position of this image will be set
\end_layout

\begin_layout Plain Layout

				<img id="imgInside#{deviceController.selectedDevice.deviceId}"
\end_layout

\begin_layout Plain Layout

				src="pictures/rollerblind_inside.jpg"
\end_layout

\begin_layout Plain Layout

				style="position: absolute; width: 104px;"
\end_layout

\begin_layout Plain Layout

				onload="rollerblind_moveToPosition(
\end_layout

\begin_layout Plain Layout

					'indexTabView:devicesForm:sliderText#{deviceController.selectedDevice.deviceI
d}',
\end_layout

\begin_layout Plain Layout

					'imgInside#{deviceController.selectedDevice.deviceId}');" />
\end_layout

\begin_layout Plain Layout

			</div>
\end_layout

\begin_layout Plain Layout

	</div>
\end_layout

\begin_layout Plain Layout

	<div style="position: absolute; bottom: 0; right: 0px;">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		//Whenever the slider is used the JavaScript method is called and therefore
 the position of the image will be set
\end_layout

\begin_layout Plain Layout

		<p:slider id="slider#{deviceController.selectedDevice.deviceId}"
\end_layout

\begin_layout Plain Layout

		for="sliderText#{deviceController.selectedDevice.deviceId}"
\end_layout

\begin_layout Plain Layout

		type="vertical"
\end_layout

\begin_layout Plain Layout

		minValue="0"
\end_layout

\begin_layout Plain Layout

		maxValue="1000"
\end_layout

\begin_layout Plain Layout

		style="height: 120px; float: right, bottom;"
\end_layout

\begin_layout Plain Layout

		onSlide="rollerblind_moveToPosition(
\end_layout

\begin_layout Plain Layout

			'indexTabView:devicesForm:sliderText#{deviceController.selectedDevice.deviceId}
',
\end_layout

\begin_layout Plain Layout

			'imgInside#{deviceController.selectedDevice.deviceId}');"
\end_layout

\begin_layout Plain Layout

		onSlideEnd="rollerblind_moveToPosition(
\end_layout

\begin_layout Plain Layout

			'indexTabView:devicesForm:sliderText#{deviceController.selectedDevice.deviceId}
',
\end_layout

\begin_layout Plain Layout

			'imgInside#{deviceController.selectedDevice.deviceId}');"/>
\end_layout

\begin_layout Plain Layout

	</div>
\end_layout

\begin_layout Plain Layout

</div>
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Subsubsection*
Fan
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/pictures/RCSServer/webinterface-fan.tiff
	scale 70

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Webinterface Fan 
\begin_inset CommandInset label
LatexCommand label
name "fig:Webinterface Fan"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
In the first row a image of a fan is shown and if it's turned on, then the
 image will rotate.
 The second row shows the current temperature and in the third row the user
 is able to set/remove the temperature condition.
\end_layout

\begin_layout Standard
If the fan is on, the image rotates.
 This feature is implemented with JavaScript and for that to happen also
 the library from 'http://raphaeljs.com' is used.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},breaklines=true,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

#fan.js
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var angle = 0, image, interval;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Initalizes the fan with help from the library 'Raphael - JavaScript Library'
\end_layout

\begin_layout Plain Layout

function initFan(divId, imgSrc) {
\end_layout

\begin_layout Plain Layout

	var R = Raphael(divId, 100, 100);
\end_layout

\begin_layout Plain Layout

	image = R.image(imgSrc, 0, 0, 100, 100);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Sets an interval with 7ms, which turns the image by 5 degrees to the right
\end_layout

\begin_layout Plain Layout

function startFan() {
\end_layout

\begin_layout Plain Layout

	clearInterval(interval);
\end_layout

\begin_layout Plain Layout

	interval = setInterval(function() { image.animate({ transform: "r" + angle
 }, 1, ""); angle += 5; }, 7);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Clears the interval and therefore stops the rotating fan
\end_layout

\begin_layout Plain Layout

function stopFan() {
\end_layout

\begin_layout Plain Layout

	clearInterval(interval);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Fan.xhtml
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

//Initializes the fan with the div below and the picture
\end_layout

\begin_layout Plain Layout

<script type="text/javascript">
\end_layout

\begin_layout Plain Layout

	initFan('rotateDiv#{deviceController.selectedDevice.deviceId}', 'pictures/fan.png'
)
\end_layout

\begin_layout Plain Layout

</script>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//If the state of the fan is on, the fan starts
\end_layout

\begin_layout Plain Layout

<c:if test="#{deviceController.currentFan.state eq 'on'}">
\end_layout

\begin_layout Plain Layout

	<script type="text/javascript">
\end_layout

\begin_layout Plain Layout

		startFan();
\end_layout

\begin_layout Plain Layout

	</script>
\end_layout

\begin_layout Plain Layout

</c:if>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Stops the fan if the state is off
\end_layout

\begin_layout Plain Layout

<c:if test="#{deviceController.currentFan.state eq 'off'}">
\end_layout

\begin_layout Plain Layout

	<script type="text/javascript">
\end_layout

\begin_layout Plain Layout

		stopFan();
\end_layout

\begin_layout Plain Layout

	</script>
\end_layout

\begin_layout Plain Layout

</c:if>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//The div of the fan
\end_layout

\begin_layout Plain Layout

<div id="rotateDiv#{deviceController.selectedDevice.deviceId}" />
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//According to the status of the fan, the right button is displayed
\end_layout

\begin_layout Plain Layout

<c:choose>
\end_layout

\begin_layout Plain Layout

	<c:when test="#{deviceController.currentFan.state eq 'off'}">
\end_layout

\begin_layout Plain Layout

		<p:commandButton value="Turn On"
\end_layout

\begin_layout Plain Layout

		action="#{deviceController.currentFanTurnOn()}"
\end_layout

\begin_layout Plain Layout

		onclick="startFan();"
\end_layout

\begin_layout Plain Layout

		update="@form" />
\end_layout

\begin_layout Plain Layout

	</c:when>
\end_layout

\begin_layout Plain Layout

	<c:when test="#{deviceController.currentFan.state eq 'on'}">
\end_layout

\begin_layout Plain Layout

		<p:commandButton value="Turn Off"
\end_layout

\begin_layout Plain Layout

		action="#{deviceController.currentFanTurnOff()}"
\end_layout

\begin_layout Plain Layout

		onclick="stopFan();"
\end_layout

\begin_layout Plain Layout

		update="@form" />
\end_layout

\begin_layout Plain Layout

	</c:when>
\end_layout

\begin_layout Plain Layout

</c:choose>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
All other devices:
\end_layout

\begin_layout Itemize
Heater
\end_layout

\begin_layout Itemize
AlarmSystem
\end_layout

\begin_layout Itemize
PowerOutlet
\end_layout

\begin_layout Itemize
Light
\end_layout

\begin_layout Standard
have a quite simple user interface.
 They are also built up with a grid an have buttons and pictures attached
 to it.
\end_layout

\begin_layout Subsection*
Profiles
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/pictures/RCSServer/webinterface-profile.tiff

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Webinterface Profile 
\begin_inset CommandInset label
LatexCommand label
name "fig:Webinterface Profile"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see in the picture 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Webinterface Profile"

\end_inset

 all profiles are shown in the table.
 The user is able to create, edit and delete these profile by selecting
 the profile in the table or simply write a name for a profile in the textfield
 and create it.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/pictures/RCSServer/webinterface-profiletask.tiff

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Webinterface add Tasks to Profile 
\begin_inset CommandInset label
LatexCommand label
name "fig:Webinterface add Tasks to Profile"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the picture 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Webinterface add Tasks to Profile"

\end_inset

 the user is able to add the tasks to the profile.
 The user is able to select an existing profile and therefore he is able
 to see the tasks which are already included in the profile and the tasks.
 Also all other tasks are shown and can be included or removed from the
 profile.
\end_layout

\begin_layout Subsection*
Settings
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/pictures/RCSServer/webinterface-settings.tiff

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Webinterface Settings 
\begin_inset CommandInset label
LatexCommand label
name "fig:Webinterface Settings"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the settings tab the user sees all MCPPlaces.
 He is able to create/edit/delete them.
 When the checkbox for logging is selected or deselected the server will
 instantly send the accordingly CallMessage to the arduino of the specified
 IP - Address.
 An important point is also that the 'Retrieve devices' - button is in this
 tab.
 If the user press this button a appropiate CallMessage is sent to all MCPPlaces
 listed.
\end_layout

\begin_layout Subsubsection
Logging Arduino
\end_layout

\begin_layout Standard
Our system has to run 24 hours a day, 7 days a week and therefore a logging
 system is needed to ensure the stability.
 Logs are stored and transmitted in LogMessages.
\end_layout

\begin_layout Standard
Any Control App, Actor or Sensor which wants to make use of logging, only
 needs to call the static Log classes method named log.
 It accepts two parameters: the Logmessage and the logLevel which is defined
 as follows:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/LogStatus.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
LogStatus 
\begin_inset CommandInset label
LatexCommand label
name "fig:LogStatus"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
All preferences related to the logging prozess are implemented in the SystemLogP
references class.
 It can be set to wich destinations logging should be done and also to which
 level debuging should be performed.
 This class holds a vector of Connection types which are described in TODO:
 add reference.
 Connections can be added and deleted from this vector.
 The level of debbuging can for example be set to ERROR so that only ERROR
 messages are sended.
 Another possible configuration would be to set it to DEBUG and in further
 consequence all messages will be sent.
\end_layout

\begin_layout Standard
The following steps must be done to construct and to invoke a example LogMessage
:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Arduino/Log_Message.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Log_Message Class 
\begin_inset CommandInset label
LatexCommand label
name "fig:Log_Message Class"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Log_Message *msg = new Log_Message();
\end_layout

\begin_layout Plain Layout

msg->setDeviceId(this->getId());
\end_layout

\begin_layout Plain Layout

char *text = (char*) malloc(30) ;
\end_layout

\begin_layout Plain Layout

sprintf(text,"%s was turned on",this->getName());
\end_layout

\begin_layout Plain Layout

msg->setLogText(text);
\end_layout

\begin_layout Plain Layout

Log::verbose(msg);
\end_layout

\begin_layout Plain Layout

delete(msg);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the first step, the message is allocated.
 Then the deviceID is set properly and the charArray named text is allocated,
 filled and setted.
 The last step sends the Logging message to the destinations configurated
 in the SystemLogPreferences class.
\end_layout

\begin_layout Subsubsection
Connection Handling
\end_layout

\begin_layout Standard
Basically, all Connections are abstracted into one layer, one class named
 Connector.
 In this class, connections are established and closed and data is also
 sended and recieved.
 
\end_layout

\begin_layout Standard
The prinzip of the connection class is that when a message is recieved,
 a callback method is beeing invoked.
 The different connection types, as there are ADK connections, serial connection
s and ethernet connections over socket are all handled individually, but
 the result is the invokation of the callback method.
 Every Connection type is periodically polled and it is proved if there
 is data available.
\end_layout

\begin_layout Standard
Every ControlApp has the ability to get the last Connection using the Connector
 class.
 Connections can then be sended back to the stored connection using a Connection
 object as argument.
 The Connection struct is defined as follows:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Arduino/Connection.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Connection Struct 
\begin_inset CommandInset label
LatexCommand label
name "fig:Connection Struct"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
It can be retrieved using the getLastConnection Method from the Connector
 struct.
 The struct contains an IP - Address and a connection type, this is an enum
 and is defined as follows:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Arduino/ConnectionType.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
ConnectionType 
\begin_inset CommandInset label
LatexCommand label
name "fig:ConnectionType"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Serial Connections
\end_layout

\begin_layout Minisec
Initialization
\end_layout

\begin_layout Standard
To initialise serial connections, initSerial has to be called wich is defined
 as following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void Connector::initSerial() 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Serial.begin(BAUDRATE); 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It's a pretty straightforward method calling only Serial.begin wich is a
 function from the Arduino framework from now on allowing to send and recieve
 data through the serial interface.
 
\end_layout

\begin_layout Minisec
Revieving Messages
\end_layout

\begin_layout Standard
Periodically, checkForSerialMessages is called.
 It proves if there is a message available and then, when recieved invokes
 the callback.
 If the connection is established and available, the following code is invoked:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

delay(5); //waiting for new charakters to arrive
\end_layout

\begin_layout Plain Layout

c = (char)Serial.read();
\end_layout

\begin_layout Plain Layout

int len = strlen(mcpMessage);
\end_layout

\begin_layout Plain Layout

mcpMessage[len] = c;
\end_layout

\begin_layout Plain Layout

mcpMessage[len+1] = '
\backslash
0';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The little delay here is needed, otherwise messages won't be fully transmitted.
 with the Serial.read method, one charakter of the message is recieved and
 then it is added to the charArray.
 Due the fact that in Strings in C normally end with an 
\backslash
0 as last charakter, it is added dynamically.
\end_layout

\begin_layout Standard
Once it is fully recieved, the callback method is called using the following
 line of code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(listener->*messageCallback)(mcpMessage); 
\end_layout

\end_inset


\end_layout

\begin_layout Minisec
Sending Messages
\end_layout

\begin_layout Standard
Sending messages is quite simple using the defined Arduino framework function
 named Serial.println() or Serial.print.
\end_layout

\begin_layout Subparagraph
Ethernet Connections
\end_layout

\begin_layout Minisec
Initialization
\end_layout

\begin_layout Standard
To initialise ethernet connections, initEthernetShield has to be called
 wich is defined as following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; 
\end_layout

\begin_layout Plain Layout

byte ip[] = { 192,168,1, 2 };
\end_layout

\begin_layout Plain Layout

void Connector::initEthernetShield() 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	this->current.ip= (byte*)malloc(sizeof(uint8_t)*4);
\end_layout

\begin_layout Plain Layout

	Ethernet.begin(mac, ip);
\end_layout

\begin_layout Plain Layout

	server.begin();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the first step, the Connector's class variable of the type Connection
 is newly allocated for further use.
 then, Ethernet is enabled using the Arduiono framework functions samed
 Ethernet.begin and server.begin.
 Ethernet.begin enables the ethernet shield and makes it available for further
 use using the mac adress and the ip adress as parameters.
 Server.begin enabled a tcp server on port 13316 for incomming connections.
\end_layout

\begin_layout Minisec
Retrieving Messages
\end_layout

\begin_layout Standard
Recieving messages over a socket connections is basically the same as retrieving
 strings over the serial Interface once the connection is established.
 Establishing connections is made as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

EthernetClient client = server.available();
\end_layout

\begin_layout Plain Layout

if (!client) return; 
\end_layout

\begin_layout Plain Layout

while(client.available)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	char c = client.read();
\end_layout

\begin_layout Plain Layout

	//input prozessing
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
At first, we had to prove wether a client is available.
 Then, while data is available, input prozessing is done periodically.
\end_layout

\begin_layout Minisec
Sending Messages
\end_layout

\begin_layout Standard
Messages are sent through the Ethernet interface using nearly the same way
 as retrieving.
 At first the connection is newly established using 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

client.connect(<ip-Adress>,13316);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
then messages can be easily sended through the open socket connection using
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

client.println(message);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Afterwards the socket is flushed and closed.
\end_layout

\begin_layout Subparagraph
ADK Connections
\end_layout

\begin_layout Minisec
Preperation
\end_layout

\begin_layout Standard
To make use of the ADK shield, two Arduino libraries must be included in
 the Arduino's libraries folder.
 They are officially published from Google and can be found at: TODO: insert
 link.
 The first library named USBHostShield is used for communicating to any
 device plugged in.
 You could, for example plug in an external mass storage device and write
 your own drivers for that.
 The second library is the USBAccessory library which mainly handles the
 communication with the Android based oponent.
\end_layout

\begin_layout Minisec
Initialization
\end_layout

\begin_layout Standard
First of all, on the top of the file, the USBAccessory library and the USBHostSh
ield library have to be included.
 Then the following initialization code has to be inserted:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

AndroidAccessory acc("<ProducerName>", "<ApplicationName>", "<Description>",
 "<Version>", "<link>", "<serial number");
\end_layout

\end_inset


\end_layout

\begin_layout Minisec
Retrieving Messages
\end_layout

\begin_layout Standard
Retrieving Messages is then as easy as retrieving serial messages.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int len = acc.read(buffer, sizeof(buffer), 1);
\end_layout

\end_inset


\end_layout

\begin_layout Minisec
Sending Messages
\end_layout

\begin_layout Standard
Sending Messages is done with only one line of code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

acc.write(erg,strlen(erg)); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is no writeln Method so if a whole line line will be sent, as it is
 our case, a '
\backslash
n' charakter has to be added at the back.
\end_layout

\begin_layout Subsubsection
Event Handling
\end_layout

\begin_layout Standard
Every ControlApp has the ability to send messages at any time to the client,
 but it has to know to which client the message will be sent.
 Normally, events are established with asynchronous sending of Call- and
 ResultMessages over a period of time.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/diagrams/Asynchronous Behavior.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Asynchronous Behavior 
\begin_inset CommandInset label
LatexCommand label
name "fig:Asynchronous Behavior"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the client is subscribing for the spezific event, there is no ned for
 sending the IP Adress as a parameter.
 Instead, every Control App can get the current Connection struct by simply
 calling
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Connector::getInstance()->getLastConnection();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then the Control App itself stores the Connection and when the event is
 called, the ResultMessage has to be constructed and sended back by calling
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Connection::getInstance()->sendResult(msg,connection);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this mechanism, events can be created using subscribe methods dynamically.
\end_layout

\begin_layout Subsubsection
Android Application
\end_layout

\begin_layout Standard
In course of developing this diploma thesis, we implemented a sample app
 for Android based tablets wich is developed to show the posibilities that
 our system offers.
 The app was implemented using Google API version 3.1.
 It allows the steering of a rollerblind ControlApp, meaning that the rollerblin
d can be moved, the condition can be set and the environment variables can
 be seen in the main interface using a well designed user interface.
 Implementing the protokoll was relatively easy, due the fact that the protokoll
 is also implemented in Java, so only minor changes had to be made.
 Interpreting the messages on the other hand, was completely new implemented.
\end_layout

\begin_layout Standard
When a message is recieved, wether through a socket connection or directly
 via the ADK, the messageInterpreter class is called wich parses the recieved
 line.
 The interprete method is partly inherited from the Java EE server, but
 some aspect have to be changed.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},breaklines=true,language={C++},tabsize=2"
inline false
status open

\begin_layout Plain Layout

Class<?> cls = Class.forName("entity.device." + deviceMessage.getDeviceType());
\end_layout

\begin_layout Plain Layout

Constructor<?> c = cls.getConstructor(new Class[] { int.class, String.class,
 String.class, String.class, String.class });
\end_layout

\begin_layout Plain Layout

deviceMessage.setCurrentState(deviceMessage.getCurrentState().substring(0,
 deviceMessage.getCurrentState().length() - 1));
\end_layout

\begin_layout Plain Layout

device = (Device) c.newInstance(deviceMessage.getDeviceId(), deviceMessage.getName(
), connection, deviceMessage.getDeviceType(), deviceMessage.getCurrentState());
\end_layout

\begin_layout Plain Layout

deviceMessage.getCurrentState()); 
\end_layout

\begin_layout Plain Layout

DeviceManager.getInstance().add(device);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reflection code seen above is needed because in the Arduino system is
 not working with databases.
 Instead, Devices are dynamically instanciated using reflection and then
 added to the global singleton class named DeviceManager.
 The DeviceManager class offers methods to add listeners when a new device
 is added.
 So when DeviceManager.getInstance().add(device) is called, the listener is
 also informed.
\end_layout

\begin_layout Standard
On the GUI side, the DeviceAddedListener is implemented wich is defined
 as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface DeviceAddedListener { 
\end_layout

\begin_layout Plain Layout

	public void onDeviceAdded(Device d);
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the main activity this interface is implemented and the relevant devices
 are filtered and stored.
 Results wich are sended after every call made, can also be retrieved using
 the following interface.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface ResultMessageListener { 
\end_layout

\begin_layout Plain Layout

public void onResultMessageRecieved(ResultMessage msg); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The main activity implements both interfaces and adds itself as listeners
 using the following code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

DeviceManager.getInstance().addListener(this); 
\end_layout

\begin_layout Plain Layout

MessageInterpreter.getInstance().addResultMessageListener(this);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once the connection is established using the permission code described in
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ADK"

\end_inset

, a new Thread is started wich polls the SensorDevice to get the Brightness
 and the Temperature every two seconds.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Thread t = new Thread(){ 
\end_layout

\begin_layout Plain Layout

	@Override 
\end_layout

\begin_layout Plain Layout

	public void run(){
\end_layout

\begin_layout Plain Layout

	while(true)
\end_layout

\begin_layout Plain Layout

		{ 
\end_layout

\begin_layout Plain Layout

		try 
\end_layout

\begin_layout Plain Layout

		{ 
\end_layout

\begin_layout Plain Layout

			sleep(2000); 
\end_layout

\begin_layout Plain Layout

		} catch (InterruptedException e) 
\end_layout

\begin_layout Plain Layout

		{ 
\end_layout

\begin_layout Plain Layout

			System.err.println(e.toString()); 
\end_layout

\begin_layout Plain Layout

		} 
\end_layout

\begin_layout Plain Layout

		if(mSensorDevice!=null) { 
\end_layout

\begin_layout Plain Layout

			mSensorDevice.brightnessRCS(); 
\end_layout

\begin_layout Plain Layout

			mSensorDevice.temperatureRCS();
\end_layout

\begin_layout Plain Layout

			} 
\end_layout

\begin_layout Plain Layout

		} 
\end_layout

\begin_layout Plain Layout

	}; 
\end_layout

\begin_layout Plain Layout

}; 
\end_layout

\begin_layout Plain Layout

t.start();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When Resultmessages are received, the listener method named OnResultMessageRecie
ved gets called.
 When the deviceId equals the sensorDevice's id, the result is interpreted
 and showed on the UI.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mTextViewTemperature.post(new Runnable() { 
\end_layout

\begin_layout Plain Layout

	public void run() { 
\end_layout

\begin_layout Plain Layout

		if(msg.getDeviceId() == mSensorDevice.getDeviceId()){
\end_layout

\begin_layout Plain Layout

			if(msg.getResult().split("=")[0].equals("temperature")){ 
\end_layout

\begin_layout Plain Layout

				mTextViewTemperature.setText(erg.split("=")[1]+ " C");
\end_layout

\begin_layout Plain Layout

				} 
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		} 
\end_layout

\begin_layout Plain Layout

	});
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Direct changing of the UI from a thread is dangerous and mustn't be done.
 So the post method is used, where the changing is posted into the UI Queue
 and then executed using the Runnable interface.
\end_layout

\begin_layout Standard
Therefore, a listener thread has to be started wich continously checks wether
 new Messages are available.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

while(true)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Thread.sleep(20);
\end_layout

\begin_layout Plain Layout

	byte[] buffer = new byte[16384];
\end_layout

\begin_layout Plain Layout

	int ret = mInputStream.read(buffer);
\end_layout

\begin_layout Plain Layout

	line = "";
\end_layout

\begin_layout Plain Layout

	for(int i=0;i<ret;i++) { 
\end_layout

\begin_layout Plain Layout

		line += (char)buffer[i]; 
\end_layout

\begin_layout Plain Layout

		Log.e("MCPADKListener", line); 
\end_layout

\begin_layout Plain Layout

		} 
\end_layout

\begin_layout Plain Layout

		if(line!=null) {
\end_layout

\begin_layout Plain Layout

			mInterpreter.interprete(line, "ADK");
\end_layout

\begin_layout Plain Layout

		} 
\end_layout

\begin_layout Plain Layout

		} catch (IOException e) { 
\end_layout

\begin_layout Plain Layout

				// TODO Auto-generated catch block e.printStackTrace(); 
\end_layout

\begin_layout Plain Layout

			} 
\end_layout

\begin_layout Plain Layout

		catch (InterruptedException e) {
\end_layout

\begin_layout Plain Layout

				// TODO Auto-generated catch block e.printStackTrace(); 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Before this step, the system checks wether ADK connection is available and
 if not proves if a socket connection is available.
 Opening a BufferedReader on this inputStream will result in receiving no
 data.
 So the data is readed charakter for charakter.
 When the message is received, the interpreter is called using 
\begin_inset Quotes gld
\end_inset

ADK
\begin_inset Quotes grd
\end_inset

 as connection parameter.
 
\end_layout

\begin_layout Paragraph
UI
\end_layout

\begin_layout Standard
The UI design is pretty simple, offering as much usability as possible.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/skropf/Documents/2011roomControllingSystem/documentation/pictures/android-app.jpg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Android User Interface 
\begin_inset CommandInset label
LatexCommand label
name "fig:Android User Interface"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
On the left side, a rollerblind is showed, offering the ability through
 the vertical slider on the right side to move the rollerblind up and down
 in realtime.
 Once the slider is released, a callmessage is sent to the rollerblind device
 with the current position as parameter.
 On the right side, the current brightness and the current temperature is
 shown, changing their values every two seconds.
 Below this area, the condition can be changed.
 It describes on wich brightness the rollerblind should move up.
 If the brightness falls below this point, the rollerblind moves up again.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Selfevaluation
\end_layout

\begin_layout Subsection
Personal experience
\end_layout

\begin_layout Subsubsection
Java EE
\end_layout

\begin_layout Subsubsection*
Primefaces & UI
\end_layout

\begin_layout Standard
Overall programming in Java EE is quite nice.
 I had several problems, but the main one was in building the ui.
 I wasn't able to figure out how exactly the property 'update' in the primefaces
 elements works.
 I surely spent about 30 hours on this
\end_layout

\begin_layout Subsubsection*
Glassfish
\end_layout

\begin_layout Standard
Another problem I experienced was with the application server Glassfish.
 Sometimes it was impossible for me to know or to read from the exception
 from where an error occurred.
 Because of these exceptions I had to create a new project, copy the whole
 code from my old project into the newly created on and then work in the
 new one onward.
 I did this about ten times and it worked again afterwards with the exactly
 same code.
\end_layout

\begin_layout Subsubsection
Arduino
\end_layout

\begin_layout Paragraph
Working with Strings
\end_layout

\begin_layout Standard
Due to the fact that the Arduino framework offers the ability to work with
 Strings, we made our life easier by making use of this library.
 But in fact, we had found one problem wich is a critical issue and should
 be fixed at fast as possible.
 When adding String objects with the 
\begin_inset Quotes gld
\end_inset

+
\begin_inset Quotes grd
\end_inset

 operator, every now and then, the pointer is not calculated successfully
 and so the output was outside the Strings scope.
 When invoking this issue about ten times or more, the Arduino system restarts
 without any other exception message.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

const String args[3] = { "foo", "bar", "baz" };
\end_layout

\begin_layout Plain Layout

while(true)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	String result = ""; 
\end_layout

\begin_layout Plain Layout

	Serial.println(result); 
\end_layout

\begin_layout Plain Layout

	result += args[0]; 
\end_layout

\begin_layout Plain Layout

	Serial.println(result);
\end_layout

\begin_layout Plain Layout

	result += args[1]; 
\end_layout

\begin_layout Plain Layout

	Serial.println(result); 
\end_layout

\begin_layout Plain Layout

	result += args[2]; 
\end_layout

\begin_layout Plain Layout

	Serial.println(result); 
\end_layout

\begin_layout Plain Layout

	Serial.println();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code above demonstrated this issue and shows that if compiled and started,
 the Arduino system will restart within seconds over and over again.
 Further discussion for this bug can be found at http://stackoverflow.com/questio
ns/5782772/arduino-difficulty-with-string-concatenation
\end_layout

\begin_layout Subparagraph
Getting the remote Ip-Adress
\end_layout

\begin_layout Standard
The Ethernet shield, is equipped with the Wiznet W5100 chip wich is rather
 powerfull.
 The Arduino library named Ethernet is basically a layer around this chip
 for easy using.
 Due to this fact, it happens that not all functions available on the chip
 are packed in the layer.
 In our case we wanted to know from wich IP-Adress the connection is established
, but there was no function available offering this availability.We discovered
 in the datasheet, that the ethernet chip has the ability to read this adress
 using custom registers defined in the datasheet.
 These four registers are named Sn_DIPR and here is our code for reading
 this registers:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void W5100Class::getSn_DIPR(uint8_t * addr)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	addr[0] = read(0x040C); //192
\end_layout

\begin_layout Plain Layout

	addr[1] = read(0x040D); //168
\end_layout

\begin_layout Plain Layout

	addr[2] = read(0x040E); //0
\end_layout

\begin_layout Plain Layout

	addr[3] = read(0x040F); //2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Using std::map
\end_layout

\begin_layout Standard
The std::map template wich we used pretty often, has an bug when accessing
 elements.
 Now and then, when the key is set to int and we tried to access this element,
 null is returned.
 But when iterating trough the map, and comparing each key with another
 key, the result is returned properly.
 So instead of calling:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return map[index];
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We made a simple workaround:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

std::map<int, Actor*>::iterator itx;
\end_layout

\begin_layout Plain Layout

for ( itx=actorMap.begin(); itx != actorMap.end(); itx++ )
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

  if(id==itx->first) return itx->second; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Linker Problem
\end_layout

\begin_layout Standard
When a library includes a file and the main sketch does not include this
 file, the linker will not find the file and the whole compiling prozess
 will fail.
 So there is only one option, to include all relevant files in the main
 sketch.
\end_layout

\begin_layout Subparagraph
Memory Problem
\end_layout

\begin_layout Standard
When implementing our system on the Arduino platform, we stretched the Arduino
 system to it's limits.
 We could never run all ControlApps during the testing phase at the same
 time.
 Due to the limited SRAM resource of 8 kBytes, every step made was designed
 to be memory friendly, but still, we weren't able to integrate all apps.
\end_layout

\begin_layout Standard
We used many techniques for creating the process more dynamically, which
 we wanted to archive, but we didn't thought of having such problems concerning
 memory use.
 These techniques were mainly developed for much larger system and more
 SRAM.
 SRAM can be extended using external chips, but within this prozess, the
 Arduino has to be resoldered.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Final words
\end_layout

\begin_layout Standard
All in all working with these technologies was quite impressing and very
 complex.
 It opens up new perspectives to know how to connect hardware with software
 in a efficient way.
 While programming this diploma thesis we got deep insights into C++, which
 we never really learned in our lessons, and very specific Java problems.
 We are very happy that we were allowed to work on this diploma thesis and
 therefore in this section.
\end_layout

\begin_layout Standard
Special thanks to our professors who supervised and supported us whenever
 we had problems concerning this thesis.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Source directory
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand
\backslash
refname{}
\end_layout

\end_inset


\begin_inset VSpace -1cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "quellen"
options "dtk"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Extensions
\end_layout

\end_body
\end_document
